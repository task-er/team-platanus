<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>3ë§¤ì¹­ ìºì£¼ì–¼ í¼ì¦</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(circle at top, #1f2937, #020617 60%);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f9fafb;
      }

      .game {
        background: rgba(15, 23, 42, 0.95);
        padding: 16px 20px 20px;
        border-radius: 18px;
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.7),
          0 0 0 1px rgba(148, 163, 184, 0.2);
        backdrop-filter: blur(12px);
      }

      .game-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }

      .game-title {
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.02em;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .game-title span {
        font-size: 13px;
        font-weight: 500;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.1);
        color: #38bdf8;
        border: 1px solid rgba(56, 189, 248, 0.4);
      }

      .stats {
        display: flex;
        gap: 10px;
        font-size: 13px;
      }

      .stat {
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.4);
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
      }

      .stat-label {
        opacity: 0.7;
      }
      .stat-value {
        font-weight: 700;
      }

      .board-wrap {
        margin-top: 6px;
        position: relative;
      }

      .board {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(8, 48px);
        grid-template-rows: repeat(8, 48px);
        gap: 6px;
        padding: 8px;
        border-radius: 14px;
        background: radial-gradient(
          circle at top,
          #020617,
          #020617 55%,
          #0b1120
        );
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 1),
          0 18px 30px rgba(15, 23, 42, 0.8);
        transition: transform 0.12s ease-out;
      }

      .board.invalid-swap {
        animation: shake 0.14s ease-in-out 0s 2;
      }

      @keyframes shake {
        0% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-3px);
        }
        50% {
          transform: translateX(3px);
        }
        75% {
          transform: translateX(-2px);
        }
        100% {
          transform: translateX(0);
        }
      }

      .tile {
        width: 48px;
        height: 48px;
        border-radius: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        color: #f9fafb;
        cursor: pointer;
        user-select: none;
        box-shadow: 0 4px 0 rgba(15, 23, 42, 0.6),
          0 0 0 1px rgba(15, 23, 42, 0.8);
        transition: transform 0.18s ease-out, box-shadow 0.18s ease-out,
          filter 0.18s ease-out, opacity 0.18s ease-out;
        position: relative;
        font-size: 24px; /* ì´ëª¨ì§€ í¬ê²Œ */
      }

      .tile::after {
        content: "";
        position: absolute;
        inset: 3px;
        border-radius: inherit;
        background: radial-gradient(
          circle at 30% 20%,
          rgba(255, 255, 255, 0.16),
          transparent 55%
        );
        opacity: 0.9;
        mix-blend-mode: screen;
        pointer-events: none;
      }

      .tile:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 0 rgba(15, 23, 42, 0.7), 0 0 0 1px rgba(15, 23, 42, 1);
        filter: brightness(1.05);
      }

      .tile.selected {
        outline: 3px solid #facc15;
        outline-offset: 2px;
        transform: translateY(-2px) scale(1.06);
        box-shadow: 0 8px 0 rgba(15, 23, 42, 0.8), 0 0 0 1px rgba(15, 23, 42, 1);
        z-index: 1;
      }

      /* ê°„ë‹¨í•œ íƒ€ì…ë³„ ë°°ê²½ìƒ‰ (ì‚´ì§ íŒŒìŠ¤í…”) */
      .tile-0 {
        background: radial-gradient(circle at 30% 20%, #fed7aa, #fb923c);
      }
      .tile-1 {
        background: radial-gradient(circle at 30% 20%, #bbf7d0, #22c55e);
      }
      .tile-2 {
        background: radial-gradient(circle at 30% 20%, #bae6fd, #3b82f6);
      }
      .tile-3 {
        background: radial-gradient(circle at 30% 20%, #f5d0fe, #a855f7);
      }
      .tile-4 {
        background: radial-gradient(circle at 30% 20%, #fecdd3, #fb7185);
      }

      /* ==== ë§¤ì¹˜ í‘œì‹œ & í„°ì§€ëŠ” ì´í™íŠ¸ ==== */

      /* 1ë‹¨ê³„: ë§¤ì¹˜ëœ ë¸”ë¡ ë°˜ì§ (í™”ë ¤í•˜ì§€ë§Œ ì§§ê²Œ) */
      .tile.matched {
        animation: match-glow 0.38s ease-in-out forwards;
      }

      @keyframes match-glow {
        0% {
          transform: scale(1);
          filter: brightness(1);
          box-shadow: 0 4px 0 rgba(15, 23, 42, 0.6),
            0 0 0 1px rgba(15, 23, 42, 0.8), 0 0 0 0 rgba(250, 204, 21, 0);
        }
        60% {
          transform: scale(1.16);
          filter: brightness(1.25);
          box-shadow: 0 6px 0 rgba(15, 23, 42, 0.7),
            0 0 0 1px rgba(15, 23, 42, 1), 0 0 20px 7px rgba(250, 204, 21, 0.95);
        }
        100% {
          transform: scale(1.08);
          filter: brightness(1.1);
          box-shadow: 0 4px 0 rgba(15, 23, 42, 0.6),
            0 0 0 1px rgba(15, 23, 42, 0.9),
            0 0 12px 4px rgba(250, 204, 21, 0.75);
        }
      }

      /* 2ë‹¨ê³„: ì‹¤ì œë¡œ í„°ì§ˆ ë•Œ (ì‚´ì§ íšŒì „í•˜ë©° ì¤„ì–´ë“¦) */
      .tile.clearing {
        animation: tile-pop 0.32s cubic-bezier(0.19, 1, 0.22, 1) forwards;
        box-shadow: none;
      }

      @keyframes tile-pop {
        0% {
          opacity: 1;
          transform: scale(1.1) rotate(0deg);
        }
        40% {
          opacity: 1;
          transform: scale(1.2) rotate(4deg);
        }
        100% {
          opacity: 0;
          transform: scale(0.2) rotate(-16deg);
        }
      }

      /* ==== ë–¨ì–´ì§€ëŠ” ì´í™íŠ¸ (ëŠë¦¬ê²Œ, ë¶€ë“œëŸ½ê²Œ) ==== */
      .tile.spawn {
        animation: tile-fall 0.55s cubic-bezier(0.19, 1, 0.22, 1) forwards;
      }

      @keyframes tile-fall {
        0% {
          opacity: 0;
          transform: translateY(-34px) scale(0.95);
        }
        65% {
          opacity: 1;
          transform: translateY(6px) scale(1.02);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      /* ==== ìŠ¤ì™‘ ì´í™íŠ¸ (ë‘ ë¸”ë¡ì´ ì„œë¡œë¥¼ í–¥í•´ ì´ë™) ==== */
      .tile.swapping {
        z-index: 2;
        transition: transform 0.18s ease-in-out;
      }
      .tile.swapping.swap-right {
        transform: translateX(100%);
      }
      .tile.swapping.swap-left {
        transform: translateX(-100%);
      }
      .tile.swapping.swap-up {
        transform: translateY(-100%);
      }
      .tile.swapping.swap-down {
        transform: translateY(100%);
      }

      .controls {
        margin-top: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        font-size: 12px;
        color: #cbd5f5;
      }

      .hint {
        opacity: 0.8;
      }

      .btn {
        border: none;
        border-radius: 999px;
        padding: 7px 14px;
        font-size: 12px;
        font-weight: 600;
        background: linear-gradient(135deg, #38bdf8, #6366f1);
        color: white;
        cursor: pointer;
        box-shadow: 0 8px 18px rgba(37, 99, 235, 0.6),
          0 0 0 1px rgba(15, 23, 42, 0.8);
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .btn span {
        font-size: 14px;
      }

      .btn:active {
        transform: translateY(1px);
        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.6),
          0 0 0 1px rgba(15, 23, 42, 0.8);
      }

      .overlay {
        position: absolute;
        inset: 0;
        border-radius: 14px;
        background: radial-gradient(
          circle at top,
          rgba(15, 23, 42, 0.1),
          rgba(15, 23, 42, 0.97)
        );
        display: none;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 16px;
        z-index: 10;
      }

      .overlay.show {
        display: flex;
      }

      .overlay-box {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .overlay-title {
        font-weight: 700;
        font-size: 18px;
      }
      .overlay-score {
        font-size: 14px;
        opacity: 0.9;
      }

      @media (max-width: 480px) {
        .board {
          grid-template-columns: repeat(8, 40px);
          grid-template-rows: repeat(8, 40px);
          gap: 5px;
        }
        .tile {
          width: 40px;
          height: 40px;
          border-radius: 12px;
          font-size: 22px;
        }
        .game {
          transform: scale(0.96);
        }
      }
    </style>
  </head>
  <body>
    <div class="game">
      <header class="game-header">
        <div class="game-title">
          âš¡ ìŒì‹ 3ë§¤ì¹­ í¼ì¦
          <span>HTML Â· CSS Â· JS</span>
        </div>
        <div class="stats">
          <div class="stat">
            <div class="stat-label">ì ìˆ˜</div>
            <div class="stat-value" id="scoreText">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">ë‚¨ì€ ì´ë™</div>
            <div class="stat-value" id="movesText">30</div>
          </div>
        </div>
      </header>

      <div class="board-wrap">
        <div class="board" id="board"></div>
        <div class="overlay" id="overlay">
          <div class="overlay-box">
            <div class="overlay-title" id="overlayTitle">ê²Œì„ ì¢…ë£Œ!</div>
            <div class="overlay-score" id="overlayScore"></div>
            <button class="btn" id="restartBtn">
              <span>â†»</span> ë‹¤ì‹œ ì‹œì‘
            </button>
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="hint">
          ì¸ì ‘í•œ ìŒì‹ ì´ëª¨ì§€ë¥¼ í´ë¦­í•´ì„œ ì„œë¡œ êµí™˜í•˜ì„¸ìš”. 3ê°œ ì´ìƒ ì´ì–´ì§€ë©´
          í™”ë ¤í•˜ê²Œ í„°ì§‘ë‹ˆë‹¤!
        </div>
        <button class="btn" id="resetBtn"><span>â†»</span> ìƒˆ íŒ</button>
      </div>
    </div>

    <script>
      const BOARD_SIZE = 8;
      const TILE_TYPES = 5;
      const MAX_MOVES = 30;
      const SWAP_DURATION = 180; // ìŠ¤ì™‘ ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„(ms)

      const EMOJIS = ["ğŸ", "ğŸ•", "ğŸ£", "ğŸ”", "ğŸ°"];

      const boardEl = document.getElementById("board");
      const scoreText = document.getElementById("scoreText");
      const movesText = document.getElementById("movesText");
      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlayScore = document.getElementById("overlayScore");
      const resetBtn = document.getElementById("resetBtn");
      const restartBtn = document.getElementById("restartBtn");

      let board = [];
      let selected = null; // { row, col }
      let score = 0;
      let moves = MAX_MOVES;
      let animating = false;

      function createEmptyBoard() {
        board = new Array(BOARD_SIZE)
          .fill(0)
          .map(() => new Array(BOARD_SIZE).fill(0));
      }

      function randomTile() {
        return Math.floor(Math.random() * TILE_TYPES);
      }

      // ê°™ì€ ì¤„ 3ê°œ ì´ìƒ ì•ˆ ìƒê¸°ë„ë¡ ì´ˆê¸° ë³´ë“œ ìƒì„±
      function generateInitialBoard() {
        createEmptyBoard();
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            let t;
            do {
              t = randomTile();
            } while (
              (c >= 2 && board[r][c - 1] === t && board[r][c - 2] === t) ||
              (r >= 2 && board[r - 1][c] === t && board[r - 2][c] === t)
            );
            board[r][c] = t;
          }
        }
      }

      /**
       * highlighted: ë§¤ì¹˜ëœ íƒ€ì¼ ë¦¬ìŠ¤íŠ¸
       * spawned: ë–¨ì–´ì§„/ìƒˆë¡œ ìƒê¸´ íƒ€ì¼ ë¦¬ìŠ¤íŠ¸
       * highlightMode: "none" | "mark" | "clear"
       */
      function renderBoard(
        highlighted = [],
        spawned = [],
        highlightMode = "none"
      ) {
        const highlightSet = new Set(
          highlighted.map((p) => `${p.row},${p.col}`)
        );
        const spawnSet = new Set(spawned.map((p) => `${p.row},${p.col}`));

        boardEl.innerHTML = "";
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            const value = board[r][c];
            const tile = document.createElement("div");
            tile.className = "tile tile-" + value;
            tile.dataset.row = r;
            tile.dataset.col = c;
            tile.textContent = EMOJIS[value % EMOJIS.length];

            const key = `${r},${c}`;

            if (selected && selected.row === r && selected.col === c) {
              tile.classList.add("selected");
            }

            if (highlightSet.has(key)) {
              if (highlightMode === "clear") {
                tile.classList.add("clearing");
              } else if (highlightMode === "mark") {
                tile.classList.add("matched");
              }
            }

            if (spawnSet.has(key)) {
              tile.classList.add("spawn");
            }

            boardEl.appendChild(tile);
          }
        }
      }

      function updateUI() {
        scoreText.textContent = score;
        movesText.textContent = moves;
      }

      function findMatches() {
        const matches = [];

        // ê°€ë¡œ ì²´í¬
        for (let r = 0; r < BOARD_SIZE; r++) {
          let runStart = 0;
          for (let c = 1; c <= BOARD_SIZE; c++) {
            const current = board[r][c];
            const prev = board[r][c - 1];
            if (c < BOARD_SIZE && current === prev && current != null) {
              continue;
            }
            const runLength = c - runStart;
            if (runLength >= 3 && board[r][runStart] != null) {
              for (let k = 0; k < runLength; k++) {
                matches.push({
                  row: r,
                  col: runStart + k,
                });
              }
            }
            runStart = c;
          }
        }

        // ì„¸ë¡œ ì²´í¬
        for (let c = 0; c < BOARD_SIZE; c++) {
          let runStart = 0;
          for (let r = 1; r <= BOARD_SIZE; r++) {
            const current = r < BOARD_SIZE ? board[r][c] : null;
            const prev = board[r - 1][c];
            if (r < BOARD_SIZE && current === prev && current != null) {
              continue;
            }
            const runLength = r - runStart;
            if (runLength >= 3 && board[runStart][c] != null) {
              for (let k = 0; k < runLength; k++) {
                matches.push({
                  row: runStart + k,
                  col: c,
                });
              }
            }
            runStart = r;
          }
        }

        // ì¤‘ë³µ ì œê±°
        const unique = [];
        const seen = new Set();
        for (const m of matches) {
          const key = `${m.row},${m.col}`;
          if (!seen.has(key)) {
            seen.add(key);
            unique.push(m);
          }
        }
        return unique;
      }

      // ì¤‘ë ¥ì„ ì ìš©í•˜ê³ , ë–¨ì–´ì§„/ìƒˆë¡œ ìƒê¸´ íƒ€ì¼ ìœ„ì¹˜ ë°˜í™˜
      function applyGravity() {
        const spawned = [];
        for (let c = 0; c < BOARD_SIZE; c++) {
          let writeRow = BOARD_SIZE - 1;
          // ì•„ë˜ì—ì„œ ìœ„ë¡œ ìŠ¤ìº”í•˜ë©´ì„œ nullì´ ì•„ë‹Œ íƒ€ì¼ì„ ì•„ë˜ë¡œ ëª¨ìŒ
          for (let r = BOARD_SIZE - 1; r >= 0; r--) {
            if (board[r][c] != null) {
              if (writeRow !== r) {
                board[writeRow][c] = board[r][c];
                board[r][c] = null;
                spawned.push({ row: writeRow, col: c });
              }
              writeRow--;
            }
          }
          // ìœ„ìª½ ë¹ˆ ì¹¸ì€ ìƒˆ íƒ€ì¼ë¡œ ì±„ìš°ê¸°
          for (let r = writeRow; r >= 0; r--) {
            board[r][c] = randomTile();
            spawned.push({ row: r, col: c });
          }
        }
        return spawned;
      }

      function handleMatches(matches, chain = 0) {
        if (!matches || matches.length === 0) {
          animating = false;
          selected = null;
          renderBoard();
          return;
        }

        const base = 10;
        score += matches.length * base * (chain + 1);
        updateUI();

        const MARK_DELAY = 380;
        const CLEAR_DELAY = 320;
        const CHAIN_DELAY = 260;

        // 1ë‹¨ê³„: ë§¤ì¹˜ í‘œì‹œ
        renderBoard(matches, [], "mark");

        setTimeout(() => {
          // 2ë‹¨ê³„: í„°ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜
          renderBoard(matches, [], "clear");

          setTimeout(() => {
            // 3ë‹¨ê³„: ì‹¤ì œ ì œê±°
            for (const pos of matches) {
              board[pos.row][pos.col] = null;
            }

            // 4ë‹¨ê³„: ì¤‘ë ¥ + ìƒˆ ë¸”ë¡
            const spawned = applyGravity();
            renderBoard([], spawned, "none");

            const nextMatches = findMatches();
            if (nextMatches.length > 0) {
              setTimeout(() => {
                handleMatches(nextMatches, chain + 1);
              }, CHAIN_DELAY);
            } else {
              moves--;
              updateUI();
              animating = false;
              selected = null;
              renderBoard();
              checkGameOver();
            }
          }, CLEAR_DELAY);
        }, MARK_DELAY);
      }

      function swapTiles(r1, c1, r2, c2) {
        const tmp = board[r1][c1];
        board[r1][c1] = board[r2][c2];
        board[r2][c2] = tmp;
      }

      function getTileElement(row, col) {
        return boardEl.querySelector(
          `.tile[data-row="${row}"][data-col="${col}"]`
        );
      }

      // ìŠ¤ì™‘ ì• ë‹ˆë©”ì´ì…˜: DOMì„ ì¬ë Œë”í•˜ì§€ ì•Šê³ , ë‘ ë¸”ëŸ­ë§Œ transform
      function trySwap(r1, c1, r2, c2) {
        if (animating) return;
        animating = true;

        const tileA = getTileElement(r1, c1);
        const tileB = getTileElement(r2, c2);
        if (!tileA || !tileB) {
          animating = false;
          return;
        }

        const horizontal = r1 === r2;

        tileA.classList.add("swapping");
        tileB.classList.add("swapping");

        if (horizontal) {
          if (c2 > c1) {
            tileA.classList.add("swap-right");
            tileB.classList.add("swap-left");
          } else {
            tileA.classList.add("swap-left");
            tileB.classList.add("swap-right");
          }
        } else {
          if (r2 > r1) {
            tileA.classList.add("swap-down");
            tileB.classList.add("swap-up");
          } else {
            tileA.classList.add("swap-up");
            tileB.classList.add("swap-down");
          }
        }

        // 1ì°¨ ìŠ¤ì™‘ ì• ë‹ˆë©”ì´ì…˜ ëë‚œ í›„
        setTimeout(() => {
          // í´ë˜ìŠ¤ ì œê±°
          tileA.classList.remove(
            "swapping",
            "swap-right",
            "swap-left",
            "swap-up",
            "swap-down"
          );
          tileB.classList.remove(
            "swapping",
            "swap-right",
            "swap-left",
            "swap-up",
            "swap-down"
          );

          // ì‹¤ì œ ë°ì´í„° ìŠ¤ì™‘
          swapTiles(r1, c1, r2, c2);
          renderBoard(); // ìƒˆ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ê·¸ë¦¼

          const matches = findMatches();
          if (matches.length === 0) {
            // ìœ íš¨í•˜ì§€ ì•Šì€ ìŠ¤ì™‘ â†’ ë‹¤ì‹œ ì›ìœ„ì¹˜ë¡œ ë˜ëŒë¦¬ëŠ” ì• ë‹ˆë©”ì´ì…˜
            const backA = getTileElement(r1, c1);
            const backB = getTileElement(r2, c2);
            if (!backA || !backB) {
              animating = false;
              selected = null;
              renderBoard();
              return;
            }

            backA.classList.add("swapping");
            backB.classList.add("swapping");

            if (horizontal) {
              if (c2 > c1) {
                backA.classList.add("swap-right");
                backB.classList.add("swap-left");
              } else {
                backA.classList.add("swap-left");
                backB.classList.add("swap-right");
              }
            } else {
              if (r2 > r1) {
                backA.classList.add("swap-down");
                backB.classList.add("swap-up");
              } else {
                backA.classList.add("swap-up");
                backB.classList.add("swap-down");
              }
            }

            setTimeout(() => {
              // ë˜ëŒë¦¬ê³ , ë°ì´í„°ë„ ì›ìœ„ì¹˜
              backA.classList.remove(
                "swapping",
                "swap-right",
                "swap-left",
                "swap-up",
                "swap-down"
              );
              backB.classList.remove(
                "swapping",
                "swap-right",
                "swap-left",
                "swap-up",
                "swap-down"
              );
              swapTiles(r1, c1, r2, c2);
              boardEl.classList.add("invalid-swap");
              renderBoard();
              setTimeout(() => {
                boardEl.classList.remove("invalid-swap");
                animating = false;
                selected = null;
                renderBoard();
              }, 150);
            }, SWAP_DURATION);
          } else {
            // ìœ íš¨í•œ ìŠ¤ì™‘ â†’ ë§¤ì¹˜ ì²˜ë¦¬
            setTimeout(() => {
              handleMatches(matches, 0);
            }, 60);
          }
        }, SWAP_DURATION);
      }

      function handleTileClick(e) {
        if (animating) return;

        const tileEl = e.target.closest(".tile");
        if (!tileEl) return;

        const row = parseInt(tileEl.dataset.row, 10);
        const col = parseInt(tileEl.dataset.col, 10);

        if (selected && selected.row === row && selected.col === col) {
          // ê°™ì€ ì¹¸ ë‹¤ì‹œ í´ë¦­ â†’ ì„ íƒ í•´ì œ
          selected = null;
          renderBoard();
          return;
        }

        if (!selected) {
          selected = { row, col };
          renderBoard();
          return;
        }

        const dr = Math.abs(selected.row - row);
        const dc = Math.abs(selected.col - col);

        if (dr + dc === 1) {
          // ì¸ì ‘ì¹¸ì´ë©´ êµí™˜ ì‹œë„
          const from = { ...selected };
          selected = { row, col }; // ë‘ ì¹¸ ë‹¤ ì„ íƒ í‘œì‹œ
          renderBoard();
          trySwap(from.row, from.col, row, col);
        } else {
          // ì¸ì ‘í•˜ì§€ ì•Šìœ¼ë©´ ì„ íƒ ìœ„ì¹˜ë§Œ ë³€ê²½
          selected = { row, col };
          renderBoard();
        }
      }

      function checkGameOver() {
        if (moves <= 0) {
          overlayTitle.textContent = "ê²Œì„ ì¢…ë£Œ!";
          overlayScore.textContent = `ìµœì¢… ì ìˆ˜: ${score.toLocaleString()}ì `;
          overlay.classList.add("show");
        }
      }

      function resetGame() {
        score = 0;
        moves = MAX_MOVES;
        selected = null;
        animating = false;
        overlay.classList.remove("show");
        generateInitialBoard();
        updateUI();
        renderBoard();
      }

      // ì´ë²¤íŠ¸ ë°”ì¸ë”©
      boardEl.addEventListener("click", handleTileClick);
      resetBtn.addEventListener("click", resetGame);
      restartBtn.addEventListener("click", resetGame);

      // ì´ˆê¸° ì‹œì‘
      resetGame();
    </script>
  </body>
</html>
