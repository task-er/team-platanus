<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>í¼ì¦ (ì¸ê²Œì„ í™”ë©´)</title>
    <style>
      * {
        box-sizing: border-box;
        padding: 0;
        margin: 0;
      }
      body {
        background: radial-gradient(circle at top, #2b2b3f, #111);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #f5f5f5;
        overflow: hidden;
      }
      #game-wrapper {
        position: relative;
      }
      canvas {
        background: #1c1c24;
        border-radius: 24px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
        touch-action: none; /* avoid scroll on drag */
        display: block;
      }
      /* íŒì—… */
      #popup {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
        background: rgba(0, 0, 0, 0.4);
        z-index: 10;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
      }
      #popup.visible {
        pointer-events: all;
        opacity: 1;
      }
      #popup .popup-content {
        min-width: 260px;
        max-width: 320px;
        background: #252535;
        border-radius: 16px;
        padding: 20px 22px 16px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
        text-align: center;
      }
      #popup-message {
        margin-bottom: 14px;
        line-height: 1.5;
        font-size: 14px;
        white-space: pre-line;
      }
      #popup-btn {
        border: none;
        border-radius: 999px;
        padding: 8px 18px;
        font-size: 14px;
        cursor: pointer;
        background: linear-gradient(135deg, #ffb347, #ffcc33);
        color: #333;
        font-weight: 600;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      }
      #popup-btn:active {
        transform: translateY(1px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      }
    </style>
  </head>
  <body>
    <div id="game-wrapper">
      <canvas id="game"></canvas>
    </div>

    <!-- ê°„ë‹¨ íŒì—… -->
    <div id="popup">
      <div class="popup-content">
        <p id="popup-message"></p>
        <button id="popup-btn">í™•ì¸</button>
      </div>
    </div>

    <script>
      // ===== ìº”ë²„ìŠ¤ & ê¸°ë³¸ ì„¸íŒ… =====
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const popupEl = document.getElementById("popup");
      const popupMsgEl = document.getElementById("popup-message");
      const popupBtnEl = document.getElementById("popup-btn");

      function showPopup(message, onOk) {
        popupMsgEl.textContent = message;
        popupEl.classList.add("visible");
        currentPopupCallback = onOk || null;
        inputEnabled = false;
      }

      function hidePopup() {
        popupEl.classList.remove("visible");
        inputEnabled = true;
      }

      let currentPopupCallback = null;
      popupBtnEl.addEventListener("click", () => {
        hidePopup();
        if (typeof currentPopupCallback === "function") {
          const cb = currentPopupCallback;
          currentPopupCallback = null;
          cb();
        }
      });

      // ===== ê²Œì„ ìƒìˆ˜ =====
      const ROWS = 8;
      const COLS = 6;

      // ìµœëŒ€ 6ì¢… ì¬ë£Œ
      const ingredients = [
        { id: 0, name: "ì¹˜ì¦ˆ", color: "#f5d259", emoji: "ğŸ§€" },
        { id: 1, name: "ë‹­ê³ ê¸°", color: "#f7a6a6", emoji: "ğŸ—" },
        { id: 2, name: "ëŒ€íŒŒ", color: "#a8e6a3", emoji: "ğŸ¥¬" },
        { id: 3, name: "ë²„ì„¯", color: "#d3c1a5", emoji: "ğŸ„" },
        { id: 4, name: "ì†Œê³ ê¸°", color: "#f08b8b", emoji: "ğŸ¥©" },
        { id: 5, name: "ì–‘íŒŒ", color: "#f6e4ff", emoji: "ğŸ§…" },
      ];

      // ì†ë‹˜ ì‹¤ì—†ëŠ” ë†ë‹´ë“¤
      const customerJokes = [
        "ì˜¤ëŠ˜ì€ ê¼¬ì¹˜ 3ê°œê¹Œì§€ë§Œ...\në‹¤ì´ì–´íŠ¸ ì¤‘ì´ê±°ë“ ìš”.",
        "ì´ ì§‘ ê¼¬ì¹˜ ë¨¹ìœ¼ë©´\nê¸°ë¶„ì´ ë ˆë²¨ì—… í•œë‹¤ë˜ë°ìš”?",
        "ê¼¬ì¹˜ í•˜ë‚˜ì— ê³ ë¯¼ í•˜ë‚˜ì”©\nì‚¬ë¼ì§€ëŠ” ê±° ë§ì£ ?",
        "ë§µì§€ëŠ” ì•Šê²Œ í•´ì£¼ì„¸ìš”.\nì œ ìœ„ì¥ì´ ì•¼ê·¼ ì¤‘ì´ë¼ì„œìš”.",
        "ì „ë¶€ íƒ€ë„ ê´œì°®ì•„ìš”.\nì œ ì¸ìƒë„ íƒ€ìˆê±°ë“ ìš”.",
        "ì¶”ì²œ ë©”ë‰´ìš”?\nì‚¬ì¥ë‹˜ì´ í–‰ë³µí•´ì§€ëŠ” ê±¸ë¡œìš”.",
      ];
      let currentJoke = customerJokes[0];

      let stage = 1;
      let grid = [];
      let orderPattern = [0, 0, 0];

      // ë ˆì´ì•„ì›ƒ ì •ë³´
      let topAreaHeight = 0;
      let boardAreaTop = 0;
      let boardAreaHeight = 0;
      let boardOffsetX = 0;
      let boardOffsetY = 0;
      let tileSize = 0;

      // ì†ë‹˜ (ìƒë‹¨ ì˜ì—­)
      let customerX = 0;
      let customerY = 0;
      let customerTargetX = 0;
      let customerEntering = true;
      const customerSpeed = 400; // px/sec

      // ì…ë ¥ / ë“œë˜ê·¸
      let inputEnabled = true;
      let isDragging = false;
      let currentPointer = { x: 0, y: 0 };
      let selection = []; // {row, col}
      let invalidSelection = [];
      let invalidFeedbackTime = 0;

      // ë¦¬í”„ë ˆì‹œ/ì• ë‹ˆë©”ì´ì…˜ í”Œë˜ê·¸
      let boardFalling = false;
      let fallStartTime = 0;
      const fallDuration = 0.4; // seconds

      // ìœ í‹¸
      function randInt(max) {
        return Math.floor(Math.random() * max);
      }

      // í˜„ì¬ ìŠ¤í…Œì´ì§€ì—ì„œ ì‚¬ìš©í•  ì¬ë£Œ ì¢…ë¥˜ ìˆ˜ (ìµœëŒ€ 6)
      function getActiveIngredientCount() {
        return Math.min(ingredients.length, stage);
      }

      // ===== ìº”ë²„ìŠ¤ í¬ê¸° & ë ˆì´ì•„ì›ƒ ì¡°ì • =====
      function resizeCanvas() {
        const maxWidth = 430; // ì„¸ë¡œ ëª¨ë°”ì¼ ëŠë‚Œ
        let width = Math.min(window.innerWidth - 20, maxWidth);
        if (width < 260) width = 260;
        const height = (width * 16) / 9; // ì„¸ë¡œ ë¹„ìœ¨

        canvas.width = width;
        canvas.height = height;

        topAreaHeight = height * 0.25;
        boardAreaTop = topAreaHeight;
        boardAreaHeight = height - topAreaHeight;

        const boardPadding = 12;
        const usableWidth = width - boardPadding * 2;
        const usableHeight = boardAreaHeight - boardPadding * 2;

        const sizeByWidth = usableWidth / COLS;
        const sizeByHeight = usableHeight / ROWS;
        tileSize = Math.min(sizeByWidth, sizeByHeight);

        const boardTotalWidth = tileSize * COLS;
        const boardTotalHeight = tileSize * ROWS;

        boardOffsetX = (width - boardTotalWidth) / 2;
        boardOffsetY = boardAreaTop + (boardAreaHeight - boardTotalHeight) / 2;

        // ì†ë‹˜ ìœ„ì¹˜ ì´ˆê¸°í™” (ì¤‘ì•™)
        customerY = topAreaHeight * 0.6;
        customerTargetX = canvas.width / 2;
        if (customerEntering) {
          customerX = canvas.width + 80;
        }
      }

      window.addEventListener("resize", resizeCanvas);

      // ===== ë³´ë“œ ê´€ë ¨ í•¨ìˆ˜ =====
      function createRandomBoard() {
        const activeCount = getActiveIngredientCount();
        grid = [];
        for (let r = 0; r < ROWS; r++) {
          const row = [];
          for (let c = 0; c < COLS; c++) {
            const type = randInt(activeCount);
            row.push({
              row: r,
              col: c,
              type,
              fallStartY: boardOffsetY + r * tileSize - tileSize * 2,
              fallEndY: boardOffsetY + r * tileSize,
            });
          }
          grid.push(row);
        }
        boardFalling = true;
        fallStartTime = performance.now() / 1000;
      }

      function generateOrder() {
        const activeCount = getActiveIngredientCount();
        orderPattern = [
          randInt(activeCount),
          randInt(activeCount),
          randInt(activeCount),
        ];
      }

      // ë“œë˜ê·¸ê°€ ë‹¬ë¼ë¶™ëŠ” ì˜ì—­ì„ ì¶•ì†Œí•œ ë²„ì „
      function coordsToCell(x, y) {
        const col = Math.floor((x - boardOffsetX) / tileSize);
        const row = Math.floor((y - boardOffsetY) / tileSize);
        if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
          // íƒ€ì¼ ë‚´ë¶€ì˜ ì¢Œí‘œ
          const tileLeft = boardOffsetX + col * tileSize;
          const tileTop = boardOffsetY + row * tileSize;
          const localX = x - tileLeft;
          const localY = y - tileTop;

          // ê°€ì¥ìë¦¬ ì˜ì—­ì€ ë¬´ì‹œ (ëŒ€ê°ì„  ì‡ê¸° ì¢‹ê²Œ)
          const margin = tileSize * 0.2; // 20% ë§Œí¼ shrink
          if (
            localX < margin ||
            localX > tileSize - margin ||
            localY < margin ||
            localY > tileSize - margin
          ) {
            return null;
          }

          return { row, col };
        }
        return null;
      }

      function cellsEqual(a, b) {
        return a.row === b.row && a.col === b.col;
      }

      function cellAlreadySelected(cell) {
        return selection.some(
          (sel) => sel.row === cell.row && sel.col === cell.col
        );
      }

      function areNeighbors(a, b) {
        const dr = Math.abs(a.row - b.row);
        const dc = Math.abs(a.col - b.col);
        return dr <= 1 && dc <= 1 && !(dr === 0 && dc === 0);
      }

      function getTileAtCell(cell) {
        return grid[cell.row][cell.col];
      }

      // DFSë¡œ ë‚¨ì€ ìœ íš¨ ë§¤ì¹˜ ìˆëŠ”ì§€ ê²€ì‚¬
      function hasAnyValidMatch() {
        if (!grid || !grid.length) return false;
        const dirs = [
          [-1, -1],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [0, 1],
          [1, -1],
          [1, 0],
          [1, 1],
        ];

        function dfs(r, c, depth, path, types) {
          if (depth === 2) {
            // ê¸¸ì´ 3ì˜ íŒ¨í„´
            const [a, b, d] = types;
            const allSame = a === b && b === d;
            const matchOrder =
              orderPattern &&
              a === orderPattern[0] &&
              b === orderPattern[1] &&
              d === orderPattern[2];
            if (allSame || matchOrder) return true;
            return false;
          }

          for (let i = 0; i < dirs.length; i++) {
            const nr = r + dirs[i][0];
            const nc = c + dirs[i][1];
            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
            let used = false;
            for (let j = 0; j < path.length; j++) {
              if (path[j][0] === nr && path[j][1] === nc) {
                used = true;
                break;
              }
            }
            if (used) continue;
            const tile = grid[nr][nc];
            if (!tile) continue;
            path.push([nr, nc]);
            types.push(tile.type);
            if (dfs(nr, nc, depth + 1, path, types)) return true;
            path.pop();
            types.pop();
          }
          return false;
        }

        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const tile = grid[r][c];
            if (!tile) continue;
            if (dfs(r, c, 0, [[r, c]], [tile.type])) {
              return true;
            }
          }
        }
        return false;
      }

      function ensureAnyValidMatchWithOptionalPopup(showMsg) {
        if (hasAnyValidMatch()) return;

        const doShuffle = () => {
          // ìœ íš¨ ë§¤ì¹˜ ë‚˜ì˜¬ ë•Œê¹Œì§€ ìƒˆ ë³´ë“œ ìƒì„±
          let safeGuard = 0;
          do {
            createRandomBoard();
            safeGuard++;
          } while (!hasAnyValidMatch() && safeGuard < 100);
        };

        if (showMsg) {
          showPopup("ë§¤ì¹˜í•  ìˆ˜ ì—†ë„¤ìš”.\níŒì„ ì„ìŠµë‹ˆë‹¤!", () => {
            doShuffle();
          });
        } else {
          doShuffle();
        }
      }

      // ===== ìŠ¤í…Œì´ì§€ ì„¸íŒ… =====
      function setupStage() {
        generateOrder();
        createRandomBoard();
        ensureAnyValidMatchWithOptionalPopup(false);

        // ì†ë‹˜ ë‹¤ì‹œ ë“±ì¥
        customerEntering = true;
        customerX = canvas.width + 80;
        customerTargetX = canvas.width / 2;

        // ìƒˆë¡œìš´ ì‹¤ì—†ëŠ” ë†ë‹´ ì„ íƒ
        currentJoke = customerJokes[randInt(customerJokes.length)];
      }

      // ===== ì„ íƒ ê²°ê³¼ ì²˜ë¦¬ =====
      function finishSelection() {
        if (selection.length !== 3) {
          selection = [];
          return;
        }

        const types = selection.map((cell) => getTileAtCell(cell).type);

        const matchesOrder =
          types[0] === orderPattern[0] &&
          types[1] === orderPattern[1] &&
          types[2] === orderPattern[2];

        const allSame = types[0] === types[1] && types[1] === types[2];

        if (matchesOrder) {
          // 1. ë ˆì‹œí”¼ì™€ ë™ì¼ â†’ í´ë¦¬ì–´
          const doneSelection = selection.slice();
          selection = [];
          invalidSelection = doneSelection;
          invalidFeedbackTime = 0.4;

          showPopup("ê¼¬ì¹˜ë¥¼ ì™„ì„±í–ˆì–´ìš”!\nì†ë‹˜ê»˜ ì œê³µí•©ë‹ˆë‹¤. ğŸ˜‹", () => {
            stage++;
            setupStage();
          });
        } else if (allSame) {
          // 2. ë ˆì‹œí”¼ì™€ ë‹¤ë¥´ì§€ë§Œ 3ê°œê°€ ë™ì¼í•œ ì¬ë£Œ â†’ íŒ¡, ë–¨ì–´ì§€ê¸°
          const toRemove = selection.slice();
          selection = [];
          popTiles(toRemove);
        } else {
          // 3. ë‚˜ë¨¸ì§€ â†’ ë¶€ë¥´ë¥´ ë–¨ë©° ì•„ë¬´ ë™ì‘ X
          invalidSelection = selection.slice();
          invalidFeedbackTime = 0.5;
          selection = [];
        }
      }

      function popTiles(cellsToRemove) {
        // ì„ íƒëœ íƒ€ì¼ ì‚­ì œ
        cellsToRemove.forEach((cell) => {
          grid[cell.row][cell.col] = null;
        });

        const activeCount = getActiveIngredientCount();
        let anyColumnFalling = false;

        for (let c = 0; c < COLS; c++) {
          const columnTiles = [];
          for (let r = 0; r < ROWS; r++) {
            if (grid[r][c]) {
              columnTiles.push(grid[r][c]);
            }
          }

          const missing = ROWS - columnTiles.length;

          // ì´ ì—´ì—ì„œë§Œ íƒ€ì¼ì´ ì œê±°ë˜ì—ˆìœ¼ë©´ ë‚™í•˜/ìƒì„±
          if (missing > 0) {
            anyColumnFalling = true;
            const newColumn = [];

            // ìƒˆ íƒ€ì¼ ìœ„ì—ì„œ ìƒì„±
            for (let i = 0; i < missing; i++) {
              const type = randInt(activeCount);
              const destRow = i;
              newColumn.push({
                row: destRow,
                col: c,
                type,
                fallStartY: boardOffsetY + (destRow - 3) * tileSize,
                fallEndY: boardOffsetY + destRow * tileSize,
              });
            }

            // ê¸°ì¡´ íƒ€ì¼ ì•„ë˜ë¡œ ë°€ê¸°
            for (let i = 0; i < columnTiles.length; i++) {
              const destRow = i + missing;
              const tile = columnTiles[i];
              tile.row = destRow;
              tile.col = c;
              tile.fallStartY =
                boardOffsetY + (destRow - missing - 1) * tileSize;
              tile.fallEndY = boardOffsetY + destRow * tileSize;
              newColumn.push(tile);
            }

            // ë‹¤ì‹œ gridì— ë°˜ì˜
            for (let r = 0; r < ROWS; r++) {
              grid[r][c] = newColumn[r];
            }
          } else {
            // ì´ ì—´ì€ ë³€í™” ì—†ìŒ â†’ ë‚™í•˜ ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ì œìë¦¬
            for (let r = 0; r < ROWS; r++) {
              const tile = grid[r][c];
              if (!tile) continue;
              tile.row = r;
              tile.col = c;
              tile.fallStartY = boardOffsetY + r * tileSize;
              tile.fallEndY = boardOffsetY + r * tileSize;
            }
          }
        }

        if (anyColumnFalling) {
          boardFalling = true;
          fallStartTime = performance.now() / 1000;
        } else {
          boardFalling = false;
        }

        // ì• ë‹ˆë©”ì´ì…˜ í›„ ë§¤ì¹˜ ê°€ëŠ¥í•œì§€ í™•ì¸
        setTimeout(() => {
          ensureAnyValidMatchWithOptionalPopup(true);
        }, fallDuration * 1000 + 100);
      }

      // ===== ì†ë‹˜ ì—…ë°ì´íŠ¸ =====
      function updateCustomer(dt) {
        if (customerEntering) {
          const dir = Math.sign(customerTargetX - customerX);
          if (Math.abs(customerTargetX - customerX) < 2) {
            customerX = customerTargetX;
            customerEntering = false;
          } else {
            customerX += dir * customerSpeed * dt;
          }
        }
      }

      // ===== ì…ë ¥ ì²˜ë¦¬ =====
      function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches && e.touches[0]) {
          return {
            x: e.touches[0].clientX - rect.left,
            y: e.touches[0].clientY - rect.top,
          };
        } else {
          return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
        }
      }

      function pointerDown(e) {
        if (!inputEnabled || boardFalling) return;
        e.preventDefault();
        const pos = getPointerPos(e);
        currentPointer = pos;
        const cell = coordsToCell(pos.x, pos.y);
        if (!cell) return;

        selection = [cell];
        isDragging = true;
      }

      function pointerMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        const pos = getPointerPos(e);
        currentPointer = pos;
        const cell = coordsToCell(pos.x, pos.y);
        if (!cell) return;

        const last = selection[selection.length - 1];
        if (!last) return;

        if (selection.length >= 3) {
          // ì´ë¯¸ 3ê°œë©´ ë” ì´ìƒ ì¶”ê°€ X
          return;
        }

        if (
          !cellsEqual(last, cell) &&
          areNeighbors(last, cell) &&
          !cellAlreadySelected(cell)
        ) {
          selection.push(cell);
        }
      }

      function pointerUp(e) {
        if (!isDragging) return;
        e.preventDefault();
        isDragging = false;
        finishSelection();
      }

      canvas.addEventListener("mousedown", pointerDown);
      canvas.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      canvas.addEventListener("touchstart", pointerDown, { passive: false });
      canvas.addEventListener("touchmove", pointerMove, { passive: false });
      window.addEventListener("touchend", pointerUp, { passive: false });
      window.addEventListener("touchcancel", pointerUp, { passive: false });

      // ===== ê·¸ë¦¬ê¸° =====
      function drawBackground() {
        // ìƒë‹¨ êµ¬ì—­
        ctx.fillStyle = "#26263a";
        ctx.fillRect(0, 0, canvas.width, topAreaHeight);

        // ì¹´ìš´í„°
        ctx.fillStyle = "#1a1a26";
        const counterHeight = 20;
        ctx.fillRect(
          0,
          topAreaHeight - counterHeight,
          canvas.width,
          counterHeight
        );

        // í•˜ë‹¨ êµ¬ì—­
        ctx.fillStyle = "#181820";
        ctx.fillRect(
          0,
          topAreaHeight,
          canvas.width,
          canvas.height - topAreaHeight
        );
      }

      function drawCustomer() {
        const w = 70;
        const h = 90;
        const x = customerX;
        const y = customerY - 50;
        const left = x - w / 2;
        const top = y - h / 2;

        // ëª¸í†µ
        ctx.fillStyle = "#ffd4a3";
        ctx.beginPath();
        ctx.roundRect(left, top, w, h, 12);
        ctx.fill();

        // ì–¼êµ´
        ctx.fillStyle = "#fff1d6";
        const faceR = 22;
        const faceCx = x;
        const faceCy = top + faceR + 4;
        ctx.beginPath();
        ctx.arc(faceCx, faceCy, faceR, 0, Math.PI * 2);
        ctx.fill();

        // ëˆˆ
        ctx.fillStyle = "#333";
        const eyeOffsetX = 7;
        ctx.beginPath();
        ctx.arc(faceCx - eyeOffsetX, faceCy - 3, 2, 0, Math.PI * 2);
        ctx.arc(faceCx + eyeOffsetX, faceCy - 3, 2, 0, Math.PI * 2);
        ctx.fill();

        // ì…
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "#333";
        ctx.beginPath();
        ctx.arc(faceCx, faceCy + 3, 6, 0.1 * Math.PI, 0.9 * Math.PI, false);
        ctx.stroke();

        // ë§í’ì„ 
        const bubbleWidth = 200;
        const bubbleHeight = 68;
        const bubbleX = canvas.width / 2;
        const bubbleY = top + h + 8;

        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.strokeStyle = "rgba(0,0,0,0.15)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.roundRect(
          bubbleX - bubbleWidth / 2,
          bubbleY,
          bubbleWidth,
          bubbleHeight,
          12
        );
        ctx.fill();
        ctx.stroke();

        // ë§í’ì„  ê¼¬ë¦¬
        ctx.beginPath();
        const tailX = bubbleX - 30;
        const tailY = bubbleY + bubbleHeight;
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(tailX + 12, tailY);
        ctx.lineTo(tailX + 4, tailY + 10);
        ctx.closePath();
        ctx.fill();

        // ì£¼ë¬¸ + ë†ë‹´ í…ìŠ¤íŠ¸
        const names = orderPattern.map((t) => ingredients[t].name);
        const emojis = orderPattern.map((t) => ingredients[t].emoji).join("");
        const text = "[" + names.join("][") + "]";
        const full = emojis + " " + text;

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // ë†ë‹´
        ctx.fillStyle = "#444";
        ctx.font = "11px system-ui";
        ctx.fillText(currentJoke, bubbleX, bubbleY + bubbleHeight / 2 - 10);

        // ì£¼ë¬¸
        ctx.fillStyle = "#222";
        ctx.font = "bold 13px system-ui";
        ctx.fillText(full, bubbleX, bubbleY + bubbleHeight / 2 + 12);

        // í˜„ì¬ ìŠ¤í…Œì´ì§€ í‘œì‹œ
        ctx.font = "12px system-ui";
        ctx.fillStyle = "#f0f0f0";
        ctx.textAlign = "left";
        ctx.fillText(`ìŠ¤í…Œì´ì§€ ${stage}`, 12, 16);
      }

      function drawBoard() {
        // ë³´ë“œ ë°°ê²½
        ctx.fillStyle = "#101018";
        ctx.beginPath();
        ctx.roundRect(
          boardOffsetX - 6,
          boardOffsetY - 6,
          tileSize * COLS + 12,
          tileSize * ROWS + 12,
          18
        );
        ctx.fill();

        // ê²©ì íƒ€ì¼
        const now = performance.now() / 1000;
        let t = 0;
        let easeT = 1;
        if (boardFalling) {
          t = Math.min((now - fallStartTime) / fallDuration, 1);
          easeT = t < 1 ? 1 - Math.pow(1 - t, 3) : 1;
          if (t >= 1) {
            boardFalling = false;
          }
        }

        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const tile = grid[r][c];
            if (!tile) continue;
            const x = boardOffsetX + c * tileSize;
            let y;

            if (boardFalling) {
              const startY = tile.fallStartY ?? boardOffsetY + r * tileSize;
              const endY = tile.fallEndY ?? boardOffsetY + r * tileSize;
              y = startY + (endY - startY) * easeT;
            } else {
              y = boardOffsetY + r * tileSize;
            }

            const ingredient = ingredients[tile.type];

            // íƒ€ì¼ ë°°ê²½
            ctx.fillStyle = ingredient.color;
            const padding = 4;
            ctx.beginPath();
            ctx.roundRect(
              x + padding,
              y + padding,
              tileSize - padding * 2,
              tileSize - padding * 2,
              10
            );
            ctx.fill();

            // ì„ íƒ/ì‹¤íŒ¨ ê°•ì¡°
            let isSelected = selection.some(
              (sel) => sel.row === r && sel.col === c
            );
            let isInvalid =
              invalidFeedbackTime > 0 &&
              invalidSelection.some((sel) => sel.row === r && sel.col === c);

            if (isSelected) {
              ctx.lineWidth = 3;
              ctx.strokeStyle = "#ffffff";
              ctx.stroke();
            } else if (isInvalid) {
              ctx.lineWidth = 3;
              ctx.strokeStyle = "#ff4d4f";
              ctx.stroke();
            }

            // í…ìŠ¤íŠ¸
            ctx.fillStyle = "#333";
            ctx.font = `${Math.floor(tileSize * 0.5)}px system-ui`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(
              ingredient.emoji,
              x + tileSize / 2,
              y + tileSize / 2 - 4
            );

            ctx.fillStyle = "#333";
            ctx.font = `${Math.floor(tileSize * 0.23)}px system-ui`;
            ctx.fillText(
              ingredient.name,
              x + tileSize / 2,
              y + tileSize / 2 + 12
            );
          }
        }

        // ë“œë˜ê·¸ ì„ 
        if (selection.length > 0) {
          ctx.strokeStyle = "rgba(255,255,255,0.9)";
          ctx.lineWidth = 3;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.beginPath();
          for (let i = 0; i < selection.length; i++) {
            const cell = selection[i];
            const cx = boardOffsetX + cell.col * tileSize + tileSize / 2;
            const cy = boardOffsetY + cell.row * tileSize + tileSize / 2;
            if (i === 0) {
              ctx.moveTo(cx, cy);
            } else {
              ctx.lineTo(cx, cy);
            }
          }
          if (isDragging && selection.length < 3) {
            ctx.lineTo(currentPointer.x, currentPointer.y);
          }
          ctx.stroke();
        }
      }

      function draw(dt) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawCustomer();
        drawBoard();
      }

      // ===== ë©”ì¸ ë£¨í”„ =====
      let lastTime = 0;
      function loop(timestamp) {
        const now = timestamp / 1000;
        const dt = lastTime ? now - lastTime : 0;
        lastTime = now;

        updateCustomer(dt);

        // ì‹¤íŒ¨ ê°•ì¡° íƒ€ì´ë¨¸
        if (invalidFeedbackTime > 0) {
          invalidFeedbackTime -= dt;
          if (invalidFeedbackTime <= 0) {
            invalidFeedbackTime = 0;
            invalidSelection = [];
          }
        }

        draw(dt);
        requestAnimationFrame(loop);
      }

      // ì´ˆê¸°í™”
      resizeCanvas();
      setupStage();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
