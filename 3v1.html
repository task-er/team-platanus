<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"
    />
    <title>ê¼¬ì¹˜ê°€ê²Œ - ì¸ê²Œì„ í…ŒìŠ¤íŠ¸</title>
    <style>
      :root {
        --bg: #0f172a; /* ì „ì²´ ë°°ê²½(ë‚¨ìƒ‰) */
        --panel: #0b1226; /* íŒ¨ë„ ë°°ê²½ */
        --shop: #13203d; /* ê°€ê²Œ ì˜ì—­ ë°°ê²½ */
        --board: #0f1e37; /* ë³´ë“œ ì˜ì—­ ë°°ê²½ */
        --line: #1f2a44; /* êµ¬ë¶„ì„  */
        --text: #e6edf7; /* ë³¸ë¬¸ í…ìŠ¤íŠ¸ */
        --muted: #9fb0cc; /* ë³´ì¡° í…ìŠ¤íŠ¸ */
        --accent: #5eead4; /* í¬ì¸íŠ¸ */
      }
      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR",
          Apple SD Gothic Neo, Arial, sans-serif;
        overscroll-behavior: none;
        touch-action: manipulation;
      }
      .wrap {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        gap: 0;
      }
      header {
        position: relative;
        z-index: 3;
        padding: 10px 14px;
        font-size: 14px;
        letter-spacing: 0.2px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0)
        );
        border-bottom: 1px solid var(--line);
      }
      header .score {
        font-weight: 700;
      }
      header .hint {
        color: var(--muted);
        font-size: 12px;
      }
      .canvases {
        position: relative;
        flex: 1;
        display: flex;
        flex-direction: column;
      }
      canvas {
        display: block;
        width: 100%;
        background: transparent;
        image-rendering: optimizeSpeed;
      }
      #shop {
        background: var(--shop);
        border-bottom: 1px solid var(--line);
      }
      #board {
        background: var(--board);
      }
      .rotate-overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        z-index: 99;
        text-align: center;
        padding: 24px;
      }
      .rotate-overlay.active {
        display: flex;
      }
      .footer {
        position: relative;
        z-index: 2;
        padding: 8px 14px;
        font-size: 11px;
        color: var(--muted);
        background: linear-gradient(
          0deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0)
        );
        border-top: 1px solid var(--line);
      }
      /* iOS Safari safe-area */
      @supports (padding: max(0px)) {
        header {
          padding-top: max(10px, env(safe-area-inset-top));
        }
        .footer {
          padding-bottom: max(8px, env(safe-area-inset-bottom));
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="score">ì™„ë£Œí•œ ì£¼ë¬¸: <span id="score">0</span></div>
        <div class="hint">ë“œë˜ê·¸ë¡œ ê°™ì€ ì¬ë£Œ ì—°ê²° â†’ ë–¼ë©´ í„°ì§</div>
      </header>
      <div class="canvases">
        <canvas id="shop"></canvas>
        <canvas id="board"></canvas>
      </div>
      <div class="footer">
        â€» ì£¼ë¬¸ì€ <b>ë§¨ ì•„ë˜ë¶€í„° ìœ„ë¡œ</b> ìˆœì„œëŒ€ë¡œë§Œ ê½‚í™ë‹ˆë‹¤. ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì—ëŠ”
        ì…ë ¥ì´ ì ê¹ë‹ˆë‹¤.
      </div>
    </div>
    <div id="rotate" class="rotate-overlay">
      ì„¸ë¡œ ëª¨ë“œì— ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.<br />ê¸°ê¸°ë¥¼ ì„¸ë¡œë¡œ ëŒë ¤ì£¼ì„¸ìš”.
    </div>

    <script>
      (() => {
        // ====== ê¸°ë³¸ ì„¤ì • ======
        const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const shopCanvas = document.getElementById("shop");
        const boardCanvas = document.getElementById("board");
        const shopCtx = shopCanvas.getContext("2d");
        const boardCtx = boardCanvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const rotateOverlay = document.getElementById("rotate");

        // ì¬ë£Œ ì •ì˜
        const ING = [
          {
            key: "leek",
            name: "ëŒ€íŒŒ",
            color: "#58c774",
            text: "íŒŒ",
            emoji: "ğŸ¥¬",
          },
          {
            key: "chicken",
            name: "ë‹­ê³ ê¸°",
            color: "#f5a623",
            text: "ë‹­",
            emoji: "ğŸ”",
          },
          {
            key: "beef",
            name: "ì†Œê³ ê¸°",
            color: "#c23b22",
            text: "ì†Œ",
            emoji: "ğŸ¥©",
          },
          {
            key: "cheese",
            name: "ì¹˜ì¦ˆ",
            color: "#ffd166",
            text: "ì¹˜",
            emoji: "ğŸ§€",
          },
        ];
        const randInt = (n) => (Math.random() * n) | 0;
        const choice = (arr) => arr[randInt(arr.length)];

        // ====== ìƒë‹¨: ì†ë‹˜/ê°€ê²Œ ë°ì´í„° ======
        const customers = []; // 3ëª…
        let completedOrders = 0;

        // ê³ ê° ìƒì„±
        function newOrder() {
          // 3ì¹¸ ê³ ì •, ì¤‘ë³µ ê°€ëŠ¥
          return [choice(ING), choice(ING), choice(ING)];
        }
        function makeCustomer(slotIndex) {
          return {
            slot: slotIndex, // 0,1,2 (ì™¼,ê°€ìš´ë°,ì˜¤)
            order: newOrder(), // ì¬ë£Œ ê°ì²´ ë°°ì—´ 3ê°œ
            progress: 0, // 0~3
            alpha: 0, // í˜ì´ë“œ ì¸
            state: "arriving", // arriving -> waiting -> leaving
            sayThanksTimer: 0, // ì™„ë£Œ í›„ ì ê¹ "ê°ì‚¬í•©ë‹ˆë‹¤!"
            skin: `hsl(${randInt(360)},30%,${60 + randInt(16)}%)`,
            hair: `hsl(${randInt(360)},45%,${25 + randInt(20)}%)`,
          };
        }

        // ====== í•˜ë‹¨: ë³´ë“œ(í—¥ìŠ¤ ì›í˜• íƒ€ì¼) ======
        // ê·¸ë¦¬ë“œ í¬ê¸°(ëª¨ë°”ì¼ ì„¸ë¡œ ê¸°ì¤€ ì ë‹¹í•œ ë°€ë„)
        const GRID = { rows: 10, cols: 7 };
        let R = 20; // ì› ë°˜ì§€ë¦„ (ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ê³„ì‚°)
        let SX = 2 * R; // ê°€ë¡œ ê°„ê²© (ì„¼í„° ê°„)
        let SY = Math.sqrt(3) * R; // ì„¸ë¡œ ê°„ê²© (ì„¼í„° ê°„)
        let OX = 0,
          OY = 0; // ë³´ë“œ ì˜¤í”„ì…‹
        const grid = []; // grid[r][c] = Tile or null

        // íƒ€ì¼ ë°ì´í„°
        function makeTile(ing, r, c, curX, curY, targetX, targetY) {
          return {
            ing,
            r,
            c,
            curX,
            curY,
            targetX,
            targetY,
            moving: false,
            pulse: 0, // ì„ íƒ ì‹œ í•˜ì´ë¼ì´íŠ¸
          };
        }
        // í˜„ì¬ r,cì˜ ìº”ë²„ìŠ¤ ì¢Œí‘œ
        function posFor(r, c) {
          const x = OX + R + c * SX + (r % 2) * (SX / 2);
          const y = OY + R + r * SY;
          return { x, y };
        }

        // ì´ì›ƒ(6ë°©í–¥) íŒì •: odd-r offset
        function neighbors(r, c) {
          const odd = r % 2 === 1;
          const list = [
            [r, c - 1],
            [r, c + 1],
            [r - 1, c],
            [r + 1, c],
            [r - 1, odd ? c + 1 : c - 1],
            [r + 1, odd ? c + 1 : c - 1],
          ];
          return list.filter(
            ([rr, cc]) => rr >= 0 && rr < GRID.rows && cc >= 0 && cc < GRID.cols
          );
        }
        function isNeighbor(a, b) {
          if (!a || !b) return false;
          const rr = Math.abs(a.r - b.r);
          const cc = Math.abs(a.c - b.c);
          if (rr > 1 || cc > 1) return false;
          // Exhaustive neighbor check using table above
          return neighbors(a.r, a.c).some((n) => n[0] === b.r && n[1] === b.c);
        }

        // ====== ë³´ë“œ ì´ˆê¸°í™” ======
        function fillRandom() {
          for (let r = 0; r < GRID.rows; r++) {
            grid[r] = [];
            for (let c = 0; c < GRID.cols; c++) {
              const ing = choice(ING);
              const { x, y } = posFor(r, c);
              grid[r][c] = makeTile(ing, r, c, x, y, x, y);
            }
          }
        }

        // ====== ì„ íƒ/ë“œë˜ê·¸ ìƒíƒœ ======
        let selecting = false;
        let selection = []; // Tile[]
        let inputLocked = false; // ë‚™í•˜ ì¤‘ ì ê¸ˆ

        function tileAtPoint(px, py) {
          // ê°„ë‹¨íˆ ì „ìˆ˜ ê²€ì‚¬(ì‘ì€ ê²©ìì´ë¯€ë¡œ ì¶©ë¶„íˆ ë¹ ë¦„)
          let best = null,
            bestD = 1e9;
          for (let r = 0; r < GRID.rows; r++) {
            for (let c = 0; c < GRID.cols; c++) {
              const t = grid[r][c];
              if (!t) continue;
              const dx = px - t.curX;
              const dy = py - t.curY;
              const d2 = dx * dx + dy * dy;
              if (d2 < R * R && d2 < bestD) {
                best = t;
                bestD = d2;
              }
            }
          }
          return best;
        }

        function beginSelect(px, py) {
          if (inputLocked) return;
          const t = tileAtPoint(px, py);
          if (!t) return;
          selecting = true;
          selection = [t];
        }
        function moveSelect(px, py) {
          if (!selecting) return;
          const t = tileAtPoint(px, py);
          if (!t) return;
          const start = selection[0];
          // ê°™ì€ ì¬ë£Œë§Œ
          if (t.ing.key !== start.ing.key) return;
          const last = selection[selection.length - 1];
          if (t === last) return;
          // ì´ë¯¸ í¬í•¨ëœ íƒ€ì¼ì¸ê°€? -> ë°”ë¡œ ì•ì´ë©´ ë°±íŠ¸ë˜í‚¹(ë˜ëŒë¦¬ê¸°) í—ˆìš©
          const idx = selection.indexOf(t);
          if (idx >= 0) {
            if (
              selection.length >= 2 &&
              selection[selection.length - 2] === t
            ) {
              // í•œ ì¹¸ ë˜ëŒë¦¬ê¸°
              selection.pop();
            }
            return;
          }
          // 6ë°©í–¥ ì´ì›ƒë§Œ
          if (isNeighbor(last, t)) {
            selection.push(t);
            t.pulse = 1;
          }
        }
        function endSelect() {
          if (!selecting) {
            selection = [];
            return;
          }
          selecting = false;
          // 2ê°œ ì´ìƒì´ì–´ì•¼ í„°ì§
          if (selection.length >= 2) {
            const poppedIng = selection[0].ing;
            popSelection(selection);
            // ì£¼ë¬¸ ì§„í–‰(í•œ ë²ˆ í„°ëœ¨ë¦´ ë•Œ ê³ ê°ë‹¹ 1ì¹¸ë§Œ ì „ì§„)
            progressCustomers(poppedIng);
          }
          // í•˜ì´ë¼ì´íŠ¸ ì´ˆê¸°í™”
          selection.forEach((t) => (t.pulse = 0));
          selection = [];
        }

        // ====== í„°ëœ¨ë¦¬ê³  ë‚™í•˜ ======
        function popSelection(list) {
          // ì¦‰ì‹œ ì œê±° â†’ ìœ„ì—ì„œ ì•„ë˜ë¡œ ì±„ì›€(ì—´ ë‹¨ìœ„), ìƒˆ íƒ€ì¼ì€ ìœ„ì—ì„œ ë–¨ì–´ì§
          // ì…ë ¥ ì ê¸ˆ
          inputLocked = true;

          // ì œê±°
          const marks = new Set();
          list.forEach((t) => marks.add(`${t.r},${t.c}`));
          for (const key of marks) {
            const [r, c] = key.split(",").map(Number);
            grid[r][c] = null;
          }

          // ë‚™í•˜ ê³„ì‚°
          // ê° ì—´ ë³„ ì•„ë˜ì—ì„œ ìœ„ë¡œ ìŠ¤ìº” â†’ ì•„ë˜ë¡œ ì••ì¶•
          for (let c = 0; c < GRID.cols; c++) {
            let write = GRID.rows - 1;
            for (let r = GRID.rows - 1; r >= 0; r--) {
              const t = grid[r][c];
              if (t) {
                if (r !== write) {
                  // ì´ë™
                  grid[write][c] = t;
                  grid[r][c] = null;
                  const { x: tx, y: ty } = posFor(write, c);
                  t.r = write;
                  t.c = c;
                  t.targetX = tx;
                  t.targetY = ty;
                  t.moving = true;
                }
                write--;
              }
            }
            // ë¹„ì–´ìˆëŠ” ì¹¸ ì±„ìš°ê¸°: ìƒˆ íƒ€ì¼ì„ ìœ„ì—ì„œ ìƒì„±í•´ ë–¨ì–´ëœ¨ë¦¼
            for (let r = write; r >= 0; r--) {
              const ing = choice(ING);
              const { x: tx, y: ty } = posFor(r, c);
              // ìœ„ìª½ ë°”ê¹¥ì—ì„œ ì¶œë°œ
              const startY = ty - (write - r + 1) * SY - SY * 1.5;
              const t = makeTile(ing, r, c, tx, startY, tx, ty);
              t.moving = true;
              grid[r][c] = t;
            }
          }
        }

        // ====== ê³ ê° ì§„í–‰/êµì²´ ======
        function progressCustomers(ing) {
          let completedNow = 0;
          for (const cu of customers) {
            if (cu.state !== "waiting") continue;
            if (cu.progress >= 3) continue;
            const need = cu.order[cu.progress];
            if (need.key === ing.key) {
              cu.progress++;
              if (cu.progress >= 3) {
                cu.state = "leaving";
                cu.sayThanksTimer = 60; // 1ì´ˆ ì •ë„ ë©”ì‹œì§€ ìœ ì§€(í”„ë ˆì„ ê¸°ë°˜)
                completedNow++;
              }
            }
          }
          if (completedNow > 0) {
            completedOrders += completedNow;
            scoreEl.textContent = String(completedOrders);
          }
        }

        // ====== ë¦¬ì‚¬ì´ì¦ˆ / ë ˆì´ì•„ì›ƒ ======
        function layout() {
          const W = window.innerWidth;
          const H = window.innerHeight;
          // ì„¸ë¡œ ëª¨ë“œ ê¶Œì¥
          rotateOverlay.classList.toggle("active", W > H);

          // ìƒ/í•˜ 1:1
          const halfH = Math.floor(H / 2);

          // ìº”ë²„ìŠ¤ í¬ê¸°(DPR ë°˜ì˜)
          function sizeCanvas(canvas, wCss, hCss) {
            canvas.style.width = wCss + "px";
            canvas.style.height = hCss + "px";
            canvas.width = Math.floor(wCss * DPR);
            canvas.height = Math.floor(hCss * DPR);
            const ctx = canvas.getContext("2d");
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
          }
          sizeCanvas(shopCanvas, W, halfH);
          sizeCanvas(boardCanvas, W, H - halfH);

          // í•˜ë‹¨ ë³´ë“œì˜ ì› ë°˜ì§€ë¦„/ê°„ê²© ì‚°ì •: (COLS+0.5)*2R <= W, ((ROWS-1)*sqrt(3)+2)*R <= H_half
          const H2 = H - halfH;
          const rByW = W / (2 * (GRID.cols + 0.5));
          const rByH = H2 / ((GRID.rows - 1) * Math.sqrt(3) + 2);
          R = Math.max(14, Math.floor(Math.min(rByW, rByH))); // ìµœì†Œ ë°˜ì§€ë¦„ ë³´ì¥
          SX = 2 * R;
          SY = Math.sqrt(3) * R;
          const usedW = GRID.cols * SX + 0.5 * SX;
          const usedH = (GRID.rows - 1) * SY + 2 * R;
          OX = (W - usedW) / 2;
          OY = (H2 - usedH) / 2;

          // ê¸°ì¡´ íƒ€ì¼ë“¤ì˜ íƒ€ê²Ÿ ìœ„ì¹˜ ê°±ì‹ (ë¦¬ì‚¬ì´ì¦ˆ ì¦‰ì‹œ ìœ„ì¹˜ ê³ ì •)
          for (let r = 0; r < GRID.rows; r++) {
            for (let c = 0; c < GRID.cols; c++) {
              const t = grid[r]?.[c];
              if (!t) continue;
              const { x, y } = posFor(r, c);
              t.curX = t.targetX = x;
              t.curY = t.targetY = y;
              t.moving = false;
            }
          }
        }

        // ====== ê·¸ë¦¬ê¸°(ìƒë‹¨) ======
        function drawShop() {
          const W = shopCanvas.width / DPR;
          const H = shopCanvas.height / DPR;
          shopCtx.clearRect(0, 0, W, H);

          // ë°”ë‹¥/í…Œì´ë¸” ì˜ì—­
          // í…Œì´ë¸” 3ê°œ ë°°ì¹˜
          const tableY = H * 0.65;
          const tableW = Math.min(140, W / 3 - 24);
          const tableH = 18;
          const slotsX = [W * 0.17, W * 0.5, W * 0.83];

          // ë°°ê²½ ì¥ì‹
          shopCtx.save();
          shopCtx.globalAlpha = 0.07;
          shopCtx.fillStyle = "#ffffff";
          for (let i = 0; i < 10; i++) {
            const x = ((i + 1) * W) / 12;
            shopCtx.fillRect(x, 0, 1, H);
          }
          shopCtx.restore();

          // í…Œì´ë¸”
          for (let i = 0; i < 3; i++) {
            const x = slotsX[i] - tableW / 2;
            shopCtx.fillStyle = "#2a375a";
            roundRect(shopCtx, x, tableY, tableW, tableH, 8, true);
            // ê·¸ë¦¼ì
            shopCtx.fillStyle = "rgba(0,0,0,.25)";
            shopCtx.beginPath();
            shopCtx.ellipse(
              slotsX[i],
              tableY + tableH + 8,
              tableW * 0.45,
              6,
              0,
              0,
              Math.PI * 2
            );
            shopCtx.fill();
          }

          // ì†ë‹˜
          customers.forEach((cu, i) => {
            const x = slotsX[cu.slot];
            const baseY = tableY - 36;
            const a = cu.alpha;
            shopCtx.save();
            shopCtx.globalAlpha = a;

            // ëª¸í†µ
            shopCtx.fillStyle = "#203154";
            roundRect(shopCtx, x - 22, baseY + 8, 44, 34, 12, true);

            // ì–¼êµ´
            shopCtx.fillStyle = cu.skin;
            shopCtx.beginPath();
            shopCtx.arc(x, baseY, 18, 0, Math.PI * 2);
            shopCtx.fill();
            // ë¨¸ë¦¬
            shopCtx.fillStyle = cu.hair;
            shopCtx.beginPath();
            shopCtx.arc(x, baseY - 6, 20, Math.PI * 2, 0, true);
            shopCtx.fill();

            // ë§í’ì„ (ì£¼ë¬¸)
            const bX = x;
            const bY = baseY - 58;
            drawSpeechBubble(shopCtx, bX, bY, 74, 60, 8, 8);

            // ê¼¬ì¹˜ ê·¸ë¦¼(ì„¸ë¡œ ë§‰ëŒ€ + 3ì¹¸)
            const stickTopY = bY + 14;
            shopCtx.strokeStyle = "#caa06b";
            shopCtx.lineWidth = 3;
            shopCtx.beginPath();
            shopCtx.moveTo(bX, stickTopY);
            shopCtx.lineTo(bX, stickTopY + 36);
            shopCtx.stroke();

            for (let k = 0; k < 3; k++) {
              const slotY = stickTopY - 6 - k * 38; // ì•„ë˜ì—ì„œ ìœ„ë¡œ
              const ing = cu.order[k];
              const filled = k < cu.progress; // ì´ë¯¸ ê½‚íŒ ì¹¸
              shopCtx.save();
              shopCtx.globalAlpha = filled ? 1 : 0.35;
              drawIngredientDisc(shopCtx, bX, slotY, 20.5, ing);
              shopCtx.restore();
            }

            // ì™„ë£Œ ë©”ì‹œì§€
            if (cu.state === "leaving" && cu.sayThanksTimer > 0) {
              shopCtx.fillStyle = "#fff";
              shopCtx.font =
                "bold 12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
              shopCtx.textAlign = "center";
              shopCtx.fillText("ê³ ë§™ìŠµë‹ˆë‹¤!", bX, bY - 10);
            }

            shopCtx.restore();
          });

          // ë³´ì¡° í…ìŠ¤íŠ¸
          shopCtx.fillStyle = "rgba(255,255,255,.25)";
          shopCtx.font =
            "10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          shopCtx.textAlign = "center";
          shopCtx.fillText(
            "í…Œì´ë¸” 3ê°œ Â· ì†ë‹˜ 3ëª… Â· ì£¼ë¬¸ì€ ë§í’ì„ ì—ì„œ í™•ì¸í•˜ì„¸ìš”",
            W / 2,
            H - 8
          );
        }

        function drawSpeechBubble(ctx, cx, cy, w, h, r, tail) {
          // ë²„ë¸”
          ctx.save();
          ctx.fillStyle = "rgba(15,23,42,.92)";
          ctx.strokeStyle = "#384a7a";
          ctx.lineWidth = 1;
          roundRect(ctx, cx - w / 2, cy - h / 2, w, h, r, true, true);
          // ê¼¬ë¦¬
          ctx.beginPath();
          ctx.moveTo(cx - 8, cy + h / 2 - 2);
          ctx.lineTo(cx + 0, cy + h / 2 + tail);
          ctx.lineTo(cx + 8, cy + h / 2 - 2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }

        // ====== ê·¸ë¦¬ê¸°(í•˜ë‹¨ ë³´ë“œ) ======
        function drawBoard() {
          const W = boardCanvas.width / DPR;
          const H = boardCanvas.height / DPR;
          boardCtx.clearRect(0, 0, W, H);

          // ë³´ë“œ ì™¸ê³½ ë¯¸ë¬˜í•œ í…Œë‘ë¦¬
          boardCtx.save();
          boardCtx.strokeStyle = "rgba(255,255,255,.06)";
          boardCtx.strokeRect(0.5, 0.5, W - 1, H - 1);
          boardCtx.restore();

          // ì„ íƒ ê²½ë¡œ(ë¼ì¸)
          if (selection.length > 0) {
            boardCtx.save();
            boardCtx.lineWidth = 6;
            boardCtx.lineCap = "round";
            boardCtx.lineJoin = "round";
            // ê·¸ë¼ë°ì´ì…˜ ë¼ì¸
            const grad = boardCtx.createLinearGradient(0, 0, W, 0);
            grad.addColorStop(0, "rgba(94,234,212,.3)");
            grad.addColorStop(1, "rgba(94,234,212,.7)");
            boardCtx.strokeStyle = grad;
            boardCtx.beginPath();
            boardCtx.moveTo(selection[0].curX, selection[0].curY);
            for (let i = 1; i < selection.length; i++) {
              boardCtx.lineTo(selection[i].curX, selection[i].curY);
            }
            boardCtx.stroke();
            boardCtx.restore();
          }

          // íƒ€ì¼ ê·¸ë¦¬ê¸°
          for (let r = 0; r < GRID.rows; r++) {
            for (let c = 0; c < GRID.cols; c++) {
              const t = grid[r][c];
              if (!t) continue;

              // í•˜ì´ë¼ì´íŠ¸ í„ìŠ¤
              if (t.pulse > 0) t.pulse = Math.max(0, t.pulse - 0.05);

              // ê·¸ë¦¼ì
              boardCtx.save();
              boardCtx.globalAlpha = 0.2;
              boardCtx.beginPath();
              boardCtx.ellipse(
                t.curX,
                t.curY + R * 0.5,
                R * 0.8,
                R * 0.35,
                0,
                0,
                Math.PI * 2
              );
              boardCtx.fillStyle = "#000";
              boardCtx.fill();
              boardCtx.restore();

              // ë³¸ì²´
              drawIngredientDisc(
                boardCtx,
                t.curX,
                t.curY,
                R * 0.92,
                t.ing,
                t.pulse
              );
            }
          }

          // ìƒíƒœ í…ìŠ¤íŠ¸
          boardCtx.fillStyle = "rgba(255,255,255,.28)";
          boardCtx.font =
            "11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
          boardCtx.textAlign = "right";
          boardCtx.fillText(
            inputLocked ? "ì±„ì›Œì§€ëŠ” ì¤‘â€¦" : "ì—°ê²°í•˜ì—¬ í„°ëœ¨ë¦¬ì„¸ìš”",
            W - 8,
            H - 8
          );
        }

        function drawIngredientDisc(ctx, x, y, rad, ing, pulse = 0) {
          const r = rad;
          // ì™¸ê³½ ë§
          ctx.save();
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          const grad = ctx.createRadialGradient(x, y, r * 0.2, x, y, r);
          grad.addColorStop(0, lighten(ing.color, 0.15));
          grad.addColorStop(1, ing.color);
          ctx.fillStyle = grad;
          ctx.fill();

          // í…Œë‘ë¦¬
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(255,255,255,.15)";
          ctx.stroke();

          // í„ìŠ¤ í•˜ì´ë¼ì´íŠ¸
          if (pulse > 0) {
            ctx.globalAlpha = pulse * 0.7;
            ctx.lineWidth = 4;
            ctx.strokeStyle = "rgba(94,234,212,.9)";
            ctx.beginPath();
            ctx.arc(x, y, r - 1, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.restore();

          // ì´ëª¨ì§€/ë¬¸ì
          ctx.save();
          ctx.font = `${Math.floor(
            r * 0.95
          )}px Apple Color Emoji, "Noto Color Emoji", system-ui, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#ffffff";
          ctx.globalAlpha = 1;
          ctx.fillText(ing.emoji, x, y + 1);
          ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r, fill = true, stroke = false) {
          const rr = Math.min(r, w / 2, h / 2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          if (fill) ctx.fill();
          if (stroke) ctx.stroke();
        }

        function lighten(hex, amt) {
          // hex -> hsl ì¡°ì • ê°„ë‹¨ ë²„ì „
          const c = parseInt(hex.replace("#", ""), 16);
          let r = (c >> 16) & 255,
            g = (c >> 8) & 255,
            b = c & 255;
          r = Math.min(255, Math.floor(r + 255 * amt));
          g = Math.min(255, Math.floor(g + 255 * amt));
          b = Math.min(255, Math.floor(b + 255 * amt));
          return `rgb(${r},${g},${b})`;
        }

        // ====== ë£¨í”„/ì—…ë°ì´íŠ¸ ======
        function update() {
          // íƒ€ì¼ ë‚™í•˜ ì• ë‹ˆë©”ì´ì…˜
          let anyMoving = false;
          for (let r = 0; r < GRID.rows; r++) {
            for (let c = 0; c < GRID.cols; c++) {
              const t = grid[r][c];
              if (!t) continue;
              if (t.moving) {
                const dy = t.targetY - t.curY;
                const dx = t.targetX - t.curX;
                // ì¤‘ë ¥ ê°€ì† ëŠë‚Œ
                const sp = Math.max(4, Math.min(24, Math.abs(dy) * 0.25 + 6));
                if (Math.abs(dx) > 1)
                  t.curX += Math.sign(dx) * Math.min(Math.abs(dx), sp * 0.4);
                if (Math.abs(dy) > 1)
                  t.curY += Math.sign(dy) * Math.min(Math.abs(dy), sp);
                if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {
                  t.curX = t.targetX;
                  t.curY = t.targetY;
                  t.moving = false;
                } else {
                  anyMoving = true;
                }
              }
            }
          }
          if (!anyMoving && inputLocked) {
            inputLocked = false; // ë‚™í•˜ ë§ˆì¹¨
          }

          // ì†ë‹˜ ìƒíƒœ
          customers.forEach((cu) => {
            if (cu.state === "arriving") {
              cu.alpha = Math.min(1, cu.alpha + 0.06);
              if (cu.alpha >= 1) cu.state = "waiting";
            } else if (cu.state === "leaving") {
              if (cu.sayThanksTimer > 0) {
                cu.sayThanksTimer--;
              } else {
                cu.alpha = Math.max(0, cu.alpha - 0.06);
                if (cu.alpha <= 0) {
                  // ìƒˆ ì†ë‹˜ìœ¼ë¡œ êµì²´
                  const slot = cu.slot;
                  Object.assign(cu, makeCustomer(slot));
                }
              }
            }
          });
        }

        function loop() {
          update();
          drawShop();
          drawBoard();
          requestAnimationFrame(loop);
        }

        // ====== ì…ë ¥ ì²˜ë¦¬(ë§ˆìš°ìŠ¤ + í„°ì¹˜) ======
        function getBoardPointFromEvent(e) {
          const rect = boardCanvas.getBoundingClientRect();
          let clientX, clientY;
          if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
          } else {
            clientX = e.clientX;
            clientY = e.clientY;
          }
          const x = clientX - rect.left;
          const y = clientY - rect.top;
          return { x, y };
        }
        boardCanvas.addEventListener("mousedown", (e) => {
          const p = getBoardPointFromEvent(e);
          beginSelect(p.x, p.y);
        });
        window.addEventListener("mousemove", (e) => {
          if (!selecting) return;
          const p = getBoardPointFromEvent(e);
          moveSelect(p.x, p.y);
        });
        window.addEventListener("mouseup", () => {
          endSelect();
        });

        boardCanvas.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            const p = getBoardPointFromEvent(e);
            beginSelect(p.x, p.y);
          },
          { passive: false }
        );
        window.addEventListener(
          "touchmove",
          (e) => {
            if (!selecting) return;
            e.preventDefault();
            const p = getBoardPointFromEvent(e);
            moveSelect(p.x, p.y);
          },
          { passive: false }
        );
        window.addEventListener(
          "touchend",
          (e) => {
            e.preventDefault();
            endSelect();
          },
          { passive: false }
        );

        // ====== ì´ˆê¸°í™” ======
        function init() {
          // ì†ë‹˜ 3ëª… ì„¸íŒ…(ìŠ¬ë¡¯ 0,1,2)
          customers.length = 0;
          customers.push(makeCustomer(0), makeCustomer(1), makeCustomer(2));
          // ë³´ë“œ
          fillRandom();
          layout();
          loop();
        }

        window.addEventListener("resize", layout);
        init();
      })();
    </script>
  </body>
</html>
