<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>3ë§¤ì¹˜ ì¥ì‚¬ ê²Œì„ - ìƒì  ì—°ì¶œ ë²„ì „</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <style>
      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #111;
        color: #fff;
        display: flex;
        justify-content: center;
        align-items: stretch;
        height: 100vh;
      }
      #gameContainer {
        width: 100%;
        max-width: 480px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: relative;
        flex: 0 0 auto;
      }
      #gameCanvas {
        width: 100%;
        height: auto;
        max-height: 100vh;
        background: #222;
        border-radius: 16px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
        touch-action: none;
        display: block;
      }
      #hud {
        width: 100%;
        max-width: 480px;
        padding: 8px 12px 12px;
        color: #eee;
        font-size: 14px;
        display: none;
      }
      #hudTop {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 4px;
        gap: 8px;
        flex-wrap: wrap;
      }
      #orderText {
        font-weight: 600;
        font-size: 14px;
      }
      #stageText {
        font-size: 13px;
        opacity: 0.7;
        margin-top: 2px;
      }
      #moneyText {
        font-size: 13px;
        font-weight: 600;
        white-space: nowrap;
        align-self: center;
        opacity: 0.9;
      }
      #inventory {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 6px;
        font-size: 13px;
      }
      .inv-item {
        padding: 2px 6px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.08);
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .color-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        flex-shrink: 0;
      }
      #serveRow {
        display: flex;
        justify-content: flex-end;
      }
      #serveButton {
        padding: 6px 14px;
        border-radius: 999px;
        border: none;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        background: #555;
        color: #ccc;
        transition: background 0.15s ease, transform 0.05s ease;
      }
      #serveButton.enabled {
        background: linear-gradient(135deg, #ffb347, #ffcc33);
        color: #222;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      }
      #serveButton.enabled:active {
        transform: translateY(1px);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
      }

      /* ì˜¤ë¥¸ìª½ ìƒì  íŒ¨ë„ */
      #shopPanel {
        width: 220px;
        max-width: 40%;
        margin-left: 12px;
        background: #181818;
        border-left: 1px solid #333;
        border-radius: 16px 0 0 16px;
        padding: 10px 12px;
        font-size: 13px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .shop-header {
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        padding-bottom: 6px;
        margin-bottom: 4px;
      }
      .shop-title {
        font-size: 15px;
        font-weight: 700;
        margin-bottom: 2px;
      }
      .shop-sub {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
      }
      #shopMoney {
        font-size: 12px;
        font-weight: 600;
        margin-bottom: 4px;
      }
      .shop-items {
        display: flex;
        flex-direction: column;
        gap: 6px;
        overflow-y: auto;
      }
      .shop-item {
        background: rgba(255, 255, 255, 0.04);
        border-radius: 10px;
        padding: 6px 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 6px;
      }
      .shop-item-info {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .shop-item-name {
        font-size: 13px;
        font-weight: 600;
      }
      .shop-item-desc {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
      }
      .shop-buy-btn {
        border-radius: 999px;
        border: none;
        padding: 4px 8px;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        white-space: nowrap;
        background: #444;
        color: #ddd;
        transition: background 0.15s ease, transform 0.05s ease,
          opacity 0.15s ease;
      }
      .shop-buy-btn.affordable {
        background: linear-gradient(135deg, #ffb347, #ffcc33);
        color: #222;
      }
      .shop-buy-btn.owned {
        background: #2ecc71;
        color: #111;
      }
      .shop-buy-btn:disabled {
        opacity: 0.6;
        cursor: default;
      }
      .shop-tip {
        font-size: 10px;
        color: rgba(255, 255, 255, 0.5);
        margin-top: 2px;
      }

      @media (max-width: 768px) {
        body {
          flex-direction: column;
          align-items: center;
        }
        #shopPanel {
          width: 100%;
          max-width: 480px;
          margin: 8px auto 0;
          border-left: none;
          border-top: 1px solid #333;
          border-radius: 16px 16px 0 0;
        }
      }

      /* íŒì—… */
      #popupOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.65);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10;
      }
      #popupBox {
        background: #1f1f1f;
        border-radius: 16px;
        padding: 16px 18px 14px;
        width: 80%;
        max-width: 340px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
      }
      #popupMsg {
        font-size: 15px;
        margin-bottom: 14px;
      }
      #popupButtons {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }
      .popup-btn {
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 14px;
        border: none;
        cursor: pointer;
        font-weight: 600;
      }
      #popupCancel {
        background: #444;
        color: #fff;
      }
      #popupConfirm {
        background: #ffb347;
        color: #222;
      }

      /* í† ìŠ¤íŠ¸ */
      #toast {
        position: fixed;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85);
        color: #fff;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 20;
      }
      #toast.show {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>

      <!-- ì¸ê²Œì„ í•˜ë‹¨ HUD -->
      <div id="hud">
        <div id="hudTop">
          <div>
            <div id="orderText">ì†ë‹˜ ì£¼ë¬¸: -</div>
            <div id="stageText">ìŠ¤í…Œì´ì§€ -</div>
          </div>
          <div id="moneyText">ğŸ’° 0ì›</div>
        </div>
        <div id="inventory"></div>
        <div id="serveRow">
          <button id="serveButton" disabled>ìŒì‹ ì œê³µí•˜ê¸°</button>
        </div>
      </div>
    </div>

    <!-- ì˜¤ë¥¸ìª½ ìƒì  -->
    <div id="shopPanel">
      <div class="shop-header">
        <div class="shop-title">ìƒì </div>
        <div class="shop-sub">í•œ íŒ í´ë¦¬ì–´í•´ì„œ ê°€ê²Œë¥¼ í‚¤ì›Œë³´ì„¸ìš”</div>
      </div>
      <div id="shopMoney">ë³´ìœ  ê¸ˆì•¡: 0ì›</div>
      <div class="shop-items">
        <div class="shop-item">
          <div class="shop-item-info">
            <div class="shop-item-name">ê°„ë‹¨ ì¸í…Œë¦¬ì–´</div>
            <div class="shop-item-desc">ë°°ê²½ê³¼ ë°”ë‹¥ì´ ì¡°ê¸ˆ ë” ì˜ˆë»ì§‘ë‹ˆë‹¤.</div>
          </div>
          <button
            class="shop-buy-btn"
            data-cost="200"
            data-name="ê°„ë‹¨ ì¸í…Œë¦¬ì–´"
            data-key="interior"
          >
            200ì›
          </button>
        </div>
        <div class="shop-item">
          <div class="shop-item-info">
            <div class="shop-item-name">í”„ë¦¬ë¯¸ì—„ ê°„íŒ</div>
            <div class="shop-item-desc">ë¡œë¹„ ìƒë‹¨ì— ë„¤ì˜¨ ê°„íŒì´ ì¼œì§‘ë‹ˆë‹¤.</div>
          </div>
          <button
            class="shop-buy-btn"
            data-cost="500"
            data-name="í”„ë¦¬ë¯¸ì—„ ê°„íŒ"
            data-key="sign"
          >
            500ì›
          </button>
        </div>
        <div class="shop-item">
          <div class="shop-item-info">
            <div class="shop-item-name">ë¹„ë°€ ë ˆì‹œí”¼ ë…¸íŠ¸</div>
            <div class="shop-item-desc">
              ì†ë‹˜ ì£¼ë¬¸ ë§í’ì„  ì£¼ë³€ì´ ê³ ê¸‰ ì£¼ë°©ì²˜ëŸ¼ ë°”ë€ë‹ˆë‹¤.
            </div>
          </div>
          <button
            class="shop-buy-btn"
            data-cost="1000"
            data-name="ë¹„ë°€ ë ˆì‹œí”¼ ë…¸íŠ¸"
            data-key="recipe"
          >
            1000ì›
          </button>
        </div>
      </div>
      <div class="shop-tip">
        â€» êµ¬ë§¤ í›„ì—ëŠ” ë°”ë¡œ ë°°ê²½ì´ ë°”ë€Œì–´ìš”. (ì•„ì´í…œì€ ì˜êµ¬ ì ìš©)
      </div>
    </div>

    <!-- ë¡œë¹„ íŒì—… -->
    <div id="popupOverlay">
      <div id="popupBox">
        <div id="popupMsg">ì¥ì‚¬ë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
        <div id="popupButtons">
          <button class="popup-btn" id="popupCancel">ì·¨ì†Œ</button>
          <button class="popup-btn" id="popupConfirm">ì˜¤ëŠ˜ì˜ ì¥ì‚¬ ì‹œì‘</button>
        </div>
      </div>
    </div>

    <!-- í† ìŠ¤íŠ¸ -->
    <div id="toast"></div>

    <script>
      // ====== ìº”ë²„ìŠ¤ ê¸°ë³¸ ì„¤ì • ======
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const LOGICAL_WIDTH = 360;
      const LOGICAL_HEIGHT = 640;
      canvas.width = LOGICAL_WIDTH;
      canvas.height = LOGICAL_HEIGHT;

      function getCanvasPos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (evt.clientX - rect.left) * scaleX,
          y: (evt.clientY - rect.top) * scaleY,
        };
      }

      // ====== DOM ======
      const hud = document.getElementById("hud");
      const orderTextEl = document.getElementById("orderText");
      const stageTextEl = document.getElementById("stageText");
      const moneyTextEl = document.getElementById("moneyText");
      const inventoryEl = document.getElementById("inventory");
      const serveButton = document.getElementById("serveButton");
      const popupOverlay = document.getElementById("popupOverlay");
      const popupCancel = document.getElementById("popupCancel");
      const popupConfirm = document.getElementById("popupConfirm");
      const toastEl = document.getElementById("toast");

      const shopMoneyEl = document.getElementById("shopMoney");
      const shopButtons = Array.from(
        document.querySelectorAll(".shop-buy-btn")
      );

      function showToast(msg, ms = 1200) {
        toastEl.textContent = msg;
        toastEl.classList.add("show");
        setTimeout(() => {
          toastEl.classList.remove("show");
        }, ms);
      }

      // ====== ìƒìˆ˜ ë° ìƒíƒœ ======
      const GAME_STATE = {
        LOBBY: "LOBBY",
        STAGE: "STAGE",
      };
      let gameState = GAME_STATE.LOBBY;

      const STAGE_COUNT = 10;
      let unlockedStage = 1;
      let currentStage = 1;

      // ëˆ
      let money = 0;

      // ì—…ê·¸ë ˆì´ë“œ ìƒíƒœ
      const upgrades = {
        interior: false,
        sign: false,
        recipe: false,
      };

      // ë¡œë¹„ ë§µ ë“œë˜ê·¸
      let mapOffsetX = LOGICAL_WIDTH / 2 - 70 / 2;
      const stageTileWidth = 70;
      const stageTileHeight = 90;
      const stageTileGap = 35;
      const totalMapWidth = STAGE_COUNT * (stageTileWidth + stageTileGap);

      let lobbyDrag = {
        active: false,
        startX: 0,
        startOffsetX: 0,
      };
      let lobbyClickDownPos = null;

      function clampMapOffset() {
        const min = LOGICAL_WIDTH - totalMapWidth - 40;
        const max = 40;
        if (mapOffsetX < min) mapOffsetX = min;
        if (mapOffsetX > max) mapOffsetX = max;
      }

      // ë§¤ì¹˜3
      const COLS = 7;
      const ROWS = 8;
      const BOARD_TOP = LOGICAL_HEIGHT * 0.25 + 8;
      const BOARD_MARGIN_X = 8;
      let tileSize = 32;
      let boardOffsetX = 0;
      let boardOffsetY = 0;

      const ingredients = [
        { id: "meat", label: "ê³ ê¸°", color: "#e74c3c" },
        { id: "veg", label: "ì±„ì†Œ", color: "#27ae60" },
        { id: "fish", label: "ìƒì„ ", color: "#3498db" },
        { id: "grain", label: "ê³¡ë¬¼", color: "#f1c40f" },
      ];
      const ING_COUNT = ingredients.length;

      let board = []; // [y][x] = tile or null

      let inventory = {};
      let order = null;

      const PHASE = {
        IDLE: "IDLE",
        SWAP_ANIM: "SWAP_ANIM",
        RESOLVE_WAIT: "RESOLVE_WAIT",
        FALLING: "FALLING",
      };
      let phase = PHASE.IDLE;

      let selectedTile = null;
      let stagePointerDownInfo = null;
      let isProcessing = false;

      // ìŠ¤ì™‘ ìƒíƒœ
      let swapState = null; // {a,b,invalid,stage:"forward"|"back", pendingMatches}

      // ë§¤ì¹˜/ì½¤ë³´ ìƒíƒœ
      let currentMatches = null;
      let resolveTimer = 0;
      let comboCount = 0;
      let comboDisplayTimer = 0;

      // íŒŒí‹°í´
      const particles = [];

      // ===== ëˆ/ìƒì  UI =====
      function updateMoneyUI() {
        if (moneyTextEl) {
          moneyTextEl.textContent = `ğŸ’° ${money.toLocaleString()}ì›`;
        }
        if (shopMoneyEl) {
          shopMoneyEl.textContent = `ë³´ìœ  ê¸ˆì•¡: ${money.toLocaleString()}ì›`;
        }
        shopButtons.forEach((btn) => {
          const key = btn.dataset.key;
          const cost = parseInt(btn.dataset.cost || "0", 10) || 0;

          // ì´ë¯¸ ë³´ìœ í•œ ì—…ê·¸ë ˆì´ë“œëŠ” ë¬´ì¡°ê±´ owned ìƒíƒœ
          if (key && upgrades[key]) {
            btn.disabled = true;
            btn.classList.remove("affordable");
            btn.classList.add("owned");
            btn.textContent = "ë³´ìœ ì¤‘";
            return;
          }

          // ì•„ì§ ë¯¸ë³´ìœ  â†’ ëˆì— ë”°ë¼ afford ì—°ì¶œ
          if (money >= cost) {
            btn.disabled = false;
            btn.classList.add("affordable");
          } else {
            btn.disabled = true;
            btn.classList.remove("affordable");
          }
        });
      }

      shopButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const cost = parseInt(btn.dataset.cost || "0", 10) || 0;
          const name = btn.dataset.name || "ì•„ì´í…œ";
          const key = btn.dataset.key;

          if (key && upgrades[key]) {
            showToast("ì´ë¯¸ êµ¬ë§¤í•œ ì•„ì´í…œì…ë‹ˆë‹¤.");
            return;
          }
          if (money < cost) {
            showToast("ëˆì´ ë¶€ì¡±í•´ìš”!");
            return;
          }

          money -= cost;
          if (key) {
            upgrades[key] = true;
          }

          btn.disabled = true;
          btn.classList.remove("affordable");
          btn.classList.add("owned");
          btn.textContent = "ë³´ìœ ì¤‘";

          updateMoneyUI();
          showToast(`${name} êµ¬ë§¤ ì™„ë£Œ!`, 1500);
        });
      });

      // ====== HUD ======
      function updateHUD() {
        if (gameState !== GAME_STATE.STAGE) {
          hud.style.display = "none";
          updateMoneyUI();
          return;
        }
        hud.style.display = "block";

        if (order) {
          const ing = ingredients[order.ingredientIndex];
          const have = inventory[order.ingredientIndex] || 0;
          orderTextEl.textContent = `ì†ë‹˜ ì£¼ë¬¸: ${ing.label} ${order.required}ê°œ (${have}/${order.required})`;
        } else {
          orderTextEl.textContent = "ì†ë‹˜ ì£¼ë¬¸: -";
        }
        stageTextEl.textContent = `ìŠ¤í…Œì´ì§€ ${currentStage}`;

        inventoryEl.innerHTML = "";
        ingredients.forEach((ing, idx) => {
          const div = document.createElement("div");
          div.className = "inv-item";
          const dot = document.createElement("div");
          dot.className = "color-dot";
          dot.style.background = ing.color;
          const span = document.createElement("span");
          span.textContent = `${ing.label}: ${inventory[idx] || 0}ê°œ`;
          div.appendChild(dot);
          div.appendChild(span);
          inventoryEl.appendChild(div);
        });

        const canServe =
          order && (inventory[order.ingredientIndex] || 0) >= order.required;
        if (canServe) {
          serveButton.disabled = false;
          serveButton.classList.add("enabled");
        } else {
          serveButton.disabled = true;
          serveButton.classList.remove("enabled");
        }

        updateMoneyUI();
      }

      // ====== ë³´ë“œ ìœ í‹¸ ======
      function computeBoardGeometry() {
        const availableWidth = LOGICAL_WIDTH - BOARD_MARGIN_X * 2;
        const availableHeight = LOGICAL_HEIGHT - BOARD_TOP - 16;
        tileSize = Math.min(availableWidth / COLS, availableHeight / ROWS);
        const totalBoardWidth = tileSize * COLS;
        const totalBoardHeight = tileSize * ROWS;
        boardOffsetX = (LOGICAL_WIDTH - totalBoardWidth) / 2;
        boardOffsetY = BOARD_TOP + (availableHeight - totalBoardHeight) / 2;
      }

      function randomIngredientIndex() {
        return Math.floor(Math.random() * ING_COUNT);
      }

      function createTile(type, x, y) {
        return {
          type,
          x,
          y,
          drawX: x * tileSize,
          drawY: y * tileSize,
          targetX: x * tileSize,
          targetY: y * tileSize,
          scale: 1,
          alpha: 1,
          clearing: false,
          scaleAnimating: false,
          doneBreaking: false,
          shakeTime: 0,
        };
      }

      function createEmptyBoard() {
        board = [];
        for (let y = 0; y < ROWS; y++) {
          const row = [];
          for (let x = 0; x < COLS; x++) {
            row.push(null);
          }
          board.push(row);
        }
      }

      function hasMatchAt(x, y) {
        const tile = board[y][x];
        if (!tile) return false;
        const type = tile.type;

        // horizontal
        let count = 1;
        let i = x - 1;
        while (i >= 0 && board[y][i] && board[y][i].type === type) {
          count++;
          i--;
        }
        i = x + 1;
        while (i < COLS && board[y][i] && board[y][i].type === type) {
          count++;
          i++;
        }
        if (count >= 3) return true;

        // vertical
        count = 1;
        let j = y - 1;
        while (j >= 0 && board[j][x] && board[j][x].type === type) {
          count++;
          j--;
        }
        j = y + 1;
        while (j < ROWS && board[j][x] && board[j][x].type === type) {
          count++;
          j++;
        }
        return count >= 3;
      }

      function findAllMatches() {
        const matchesSet = new Set();

        // horizontal
        for (let y = 0; y < ROWS; y++) {
          let runStart = 0;
          while (runStart < COLS) {
            const tile = board[y][runStart];
            if (!tile) {
              runStart++;
              continue;
            }
            const type = tile.type;
            let runEnd = runStart + 1;
            while (
              runEnd < COLS &&
              board[y][runEnd] &&
              board[y][runEnd].type === type
            ) {
              runEnd++;
            }
            const length = runEnd - runStart;
            if (length >= 3) {
              for (let x = runStart; x < runEnd; x++) {
                matchesSet.add(`${x},${y}`);
              }
            }
            runStart = runEnd;
          }
        }

        // vertical
        for (let x = 0; x < COLS; x++) {
          let runStart = 0;
          while (runStart < ROWS) {
            const tile = board[runStart][x];
            if (!tile) {
              runStart++;
              continue;
            }
            const type = tile.type;
            let runEnd = runStart + 1;
            while (
              runEnd < ROWS &&
              board[runEnd][x] &&
              board[runEnd][x].type === type
            ) {
              runEnd++;
            }
            const length = runEnd - runStart;
            if (length >= 3) {
              for (let y = runStart; y < runEnd; y++) {
                matchesSet.add(`${x},${y}`);
              }
            }
            runStart = runEnd;
          }
        }

        const result = [];
        for (const key of matchesSet) {
          const [sx, sy] = key.split(",");
          result.push({ x: parseInt(sx), y: parseInt(sy) });
        }
        return result;
      }

      function swapTilesGrid(x1, y1, x2, y2) {
        const t1 = board[y1][x1];
        const t2 = board[y2][x2];
        board[y1][x1] = t2;
        board[y2][x2] = t1;
        if (t1) {
          t1.x = x2;
          t1.y = y2;
          t1.targetX = t1.x * tileSize;
          t1.targetY = t1.y * tileSize;
        }
        if (t2) {
          t2.x = x1;
          t2.y = y1;
          t2.targetX = t2.x * tileSize;
          t2.targetY = t2.y * tileSize;
        }
      }

      function hasAnyPossibleMove() {
        // íƒ€ì…ë§Œ ìŠ¤ì™‘í•´ì„œ ê²€ì‚¬
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const tile = board[y][x];
            if (!tile) continue;

            // ì˜¤ë¥¸ìª½
            if (x < COLS - 1) {
              const neighbor = board[y][x + 1];
              if (neighbor) {
                const t1 = tile.type;
                const t2 = neighbor.type;
                tile.type = t2;
                neighbor.type = t1;
                const possible = hasMatchAt(x, y) || hasMatchAt(x + 1, y);
                tile.type = t1;
                neighbor.type = t2;
                if (possible) return true;
              }
            }

            // ì•„ë˜
            if (y < ROWS - 1) {
              const neighbor2 = board[y + 1][x];
              if (neighbor2) {
                const t1 = tile.type;
                const t2 = neighbor2.type;
                tile.type = t2;
                neighbor2.type = t1;
                const possible = hasMatchAt(x, y) || hasMatchAt(x, y + 1);
                tile.type = t1;
                neighbor2.type = t2;
                if (possible) return true;
              }
            }
          }
        }
        return false;
      }

      function collapseBoardAnimated() {
        for (let x = 0; x < COLS; x++) {
          let writeY = ROWS - 1;

          for (let y = ROWS - 1; y >= 0; y--) {
            const tile = board[y][x];
            if (tile) {
              if (writeY !== y) {
                board[writeY][x] = tile;
                board[y][x] = null;
                tile.y = writeY;
                tile.targetY = tile.y * tileSize;
              }
              writeY--;
            }
          }

          for (let y = writeY; y >= 0; y--) {
            const type = randomIngredientIndex();
            const t = createTile(type, x, y);
            t.drawY = (y - 6) * tileSize; // ìœ„ì—ì„œ ë–¨ì–´ì§€ê²Œ
            t.targetY = y * tileSize;
            board[y][x] = t;
          }
        }
      }

      function isBoardStable() {
        const threshold = 0.5;
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const t = board[y][x];
            if (!t) continue;
            if (
              Math.abs(t.drawY - t.targetY) > threshold ||
              Math.abs(t.drawX - t.targetX) > threshold
            ) {
              return false;
            }
          }
        }
        return true;
      }

      function reshuffleBoardTypesUntilMovable() {
        let attempts = 0;
        while (attempts < 50) {
          const allTiles = [];
          for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
              const t = board[y][x];
              if (t) allTiles.push(t);
            }
          }

          // ëœë¤ íƒ€ì… ì¬ë°°ì¹˜
          for (let i = allTiles.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmpType = allTiles[i].type;
            allTiles[i].type = allTiles[j].type;
            allTiles[j].type = tmpType;
          }

          // 3ë§¤ì¹˜ ì œê±°
          let hasInitialMatch = false;
          for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
              if (hasMatchAt(x, y)) {
                hasInitialMatch = true;
                break;
              }
            }
            if (hasInitialMatch) break;
          }

          if (!hasInitialMatch && hasAnyPossibleMove()) return;
          attempts++;
        }
      }

      // ===== íŒŒí‹°í´ =====
      function spawnParticlesAtTile(tile, count = 6) {
        const centerX = boardOffsetX + tile.drawX + tileSize / 2;
        const centerY = boardOffsetY + tile.drawY + tileSize / 2;
        const baseColor = ingredients[tile.type].color;

        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 40 + Math.random() * 80;
          particles.push({
            x: centerX,
            y: centerY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0,
            duration: 0.45 + Math.random() * 0.2,
            size: 2 + Math.random() * 3,
            color: baseColor,
          });
        }
      }

      function updateParticles(delta) {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life += delta;
          p.x += p.vx * delta;
          p.y += p.vy * delta;
          p.vy += 120 * delta; // gravity
          if (p.life >= p.duration) {
            particles.splice(i, 1);
          }
        }
      }

      function drawParticles() {
        for (const p of particles) {
          const t = p.life / p.duration;
          const alpha = 1 - t;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
          ctx.restore();
        }
      }

      // ===== ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸ =====
      function updateAnimations(delta) {
        const moveSpeed = 16;

        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const t = board[y][x];
            if (!t) continue;

            t.drawX += (t.targetX - t.drawX) * delta * moveSpeed;
            t.drawY += (t.targetY - t.drawY) * delta * moveSpeed;

            if (t.scaleAnimating) {
              t.scale -= delta * 4;
              t.alpha -= delta * 4;
              if (t.scale < 0.1) t.scale = 0.1;
              if (t.alpha < 0) t.alpha = 0;
              if (t.alpha <= 0.01) {
                t.doneBreaking = true;
              }
            }

            if (t.shakeTime > 0) {
              t.shakeTime -= delta;
              if (t.shakeTime < 0) t.shakeTime = 0;
            }
          }
        }

        updateParticles(delta);
      }

      function tilesNearTarget(tiles) {
        const threshold = 0.8;
        for (const t of tiles) {
          if (!t) continue;
          if (
            Math.abs(t.drawX - t.targetX) > threshold ||
            Math.abs(t.drawY - t.targetY) > threshold
          ) {
            return false;
          }
        }
        return true;
      }

      // ===== ë§¤ì¹­ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ =====
      function startResolveWithMatches(matches) {
        currentMatches = matches;
        const explosionDuration = 0.25;
        resolveTimer = explosionDuration;
        phase = PHASE.RESOLVE_WAIT;

        // ì½¤ë³´ ì‹œì‘/ëˆ„ì 
        comboCount++;
        comboDisplayTimer = 0.6;

        // íƒ€ì¼ í­ë°œ ì• ë‹ˆë©”ì´ì…˜ + íŒŒí‹°í´, í”ë“¤ë¦¼
        for (const pos of matches) {
          const t = board[pos.y][pos.x];
          if (!t) continue;
          t.clearing = true;
          t.scaleAnimating = true;
          t.shakeTime = 0.2;
          spawnParticlesAtTile(t, 8);
        }
      }

      function updateStageLogic(delta) {
        switch (phase) {
          case PHASE.IDLE:
            break;
          case PHASE.SWAP_ANIM:
            if (!swapState) {
              phase = PHASE.IDLE;
              isProcessing = false;
              break;
            }
            if (tilesNearTarget([swapState.a, swapState.b])) {
              if (swapState.stage === "forward") {
                if (swapState.invalid) {
                  // ì˜ëª»ëœ ìŠ¤ì™‘ â†’ ë‹¤ì‹œ ì›ìœ„ì¹˜
                  swapState.a.shakeTime = 0.15;
                  swapState.b.shakeTime = 0.15;

                  const ax = swapState.a.x;
                  const ay = swapState.a.y;
                  const bx = swapState.b.x;
                  const by = swapState.b.y;
                  swapTilesGrid(ax, ay, bx, by);
                  swapState.stage = "back";
                } else {
                  // ì •ìƒ ë§¤ì¹˜ â†’ ë§¤ì¹­ ì²˜ë¦¬ ì‹œì‘
                  const matches = swapState.pendingMatches;
                  swapState = null;
                  phase = PHASE.RESOLVE_WAIT;
                  currentMatches = matches;
                  startResolveWithMatches(matches);
                }
              } else if (swapState.stage === "back") {
                swapState = null;
                phase = PHASE.IDLE;
                isProcessing = false;
              }
            }
            break;
          case PHASE.RESOLVE_WAIT:
            resolveTimer -= delta;
            if (resolveTimer <= 0 && currentMatches) {
              for (const pos of currentMatches) {
                const t = board[pos.y][pos.x];
                if (!t) continue;
                inventory[t.type] = (inventory[t.type] || 0) + 1;
                board[pos.y][pos.x] = null;
              }
              currentMatches = null;
              updateHUD();
              collapseBoardAnimated();
              phase = PHASE.FALLING;
            }
            break;
          case PHASE.FALLING:
            if (isBoardStable()) {
              const matches = findAllMatches();
              if (matches.length > 0) {
                startResolveWithMatches(matches);
              } else {
                if (comboCount > 1) {
                  showToast(`${comboCount} ì½¤ë³´!`);
                }
                comboCount = 0;
                if (!hasAnyPossibleMove()) {
                  reshuffleBoardTypesUntilMovable();
                }
                phase = PHASE.IDLE;
                isProcessing = false;
              }
            }
            break;
        }

        if (comboDisplayTimer > 0) {
          comboDisplayTimer -= delta;
          if (comboDisplayTimer < 0) comboDisplayTimer = 0;
        }
      }

      // ===== ìŠ¤ì™‘ ì‹œë„ =====
      function attemptSwapAndResolve(x1, y1, x2, y2) {
        if (isProcessing) return;
        const t1 = board[y1][x1];
        const t2 = board[y2][x2];
        if (!t1 || !t2) return;

        isProcessing = true;

        swapTilesGrid(x1, y1, x2, y2);

        const matches = findAllMatches();
        const invalid = matches.length === 0;

        t1.drawX = x1 * tileSize;
        t1.drawY = y1 * tileSize;
        t2.drawX = x2 * tileSize;
        t2.drawY = y2 * tileSize;

        swapState = {
          a: t1,
          b: t2,
          invalid,
          stage: "forward",
          pendingMatches: invalid ? null : matches,
        };
        phase = PHASE.SWAP_ANIM;
      }

      function getTileFromPos(px, py) {
        const x = Math.floor((px - boardOffsetX) / tileSize);
        const y = Math.floor((py - boardOffsetY) / tileSize);
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return null;
        return { x, y };
      }

      // ===== ìŠ¤í…Œì´ì§€ ì‹œì‘/ì¢…ë£Œ =====
      function startStage(stageNum) {
        currentStage = stageNum;
        gameState = GAME_STATE.STAGE;
        phase = PHASE.IDLE;
        isProcessing = false;
        swapState = null;
        currentMatches = null;
        comboCount = 0;
        comboDisplayTimer = 0;
        particles.length = 0;

        computeBoardGeometry();
        generateInitialBoard();

        const requiredBase = 5;
        const perStage = 2;
        const required = Math.min(
          requiredBase + (currentStage - 1) * perStage,
          20
        );
        const ingIndex = Math.floor(Math.random() * ING_COUNT);
        order = {
          ingredientIndex: ingIndex,
          required,
        };
        inventory = {};
        ingredients.forEach((_, idx) => (inventory[idx] = 0));

        updateHUD();
      }

      function generateInitialBoard() {
        createEmptyBoard();
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            let type;
            let safety = 0;
            do {
              type = randomIngredientIndex();
              board[y][x] = createTile(type, x, y);
              safety++;
            } while (hasMatchAt(x, y) && safety < 50);
          }
        }
        let safety = 0;
        while (!hasAnyPossibleMove() && safety < 30) {
          for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
              const type = randomIngredientIndex();
              board[y][x].type = type;
            }
          }
          safety++;
        }
      }

      function clearStageAndReturnToLobby() {
        // ëˆ ë³´ìƒ: ê¸°ë³¸ 100 + ìŠ¤í…Œì´ì§€ë‹¹ 20ì”© ì¦ê°€
        const reward = 100 + (currentStage - 1) * 20;
        money += reward;

        let msg = `ìŠ¤í…Œì´ì§€ ${currentStage} í´ë¦¬ì–´! ${reward.toLocaleString()}ì› ë²Œì—ˆìŠµë‹ˆë‹¤.`;
        if (currentStage === unlockedStage && unlockedStage < STAGE_COUNT) {
          unlockedStage++;
          msg += " ë‹¤ìŒ ìŠ¤í…Œì´ì§€ê°€ ì—´ë ¸ìŠµë‹ˆë‹¤.";
        }
        showToast(msg, 1800);
        updateMoneyUI();

        gameState = GAME_STATE.LOBBY;
        order = null;
        selectedTile = null;
        stagePointerDownInfo = null;
        phase = PHASE.IDLE;
        isProcessing = false;
        swapState = null;
        currentMatches = null;
        comboCount = 0;
        comboDisplayTimer = 0;
        particles.length = 0;
        updateHUD();
      }

      // ===== ë¡œë¹„ íŒì—… =====
      let pendingStageStart = null;
      function openStartPopup(stageNum) {
        pendingStageStart = stageNum;
        popupOverlay.style.display = "flex";
      }
      function closeStartPopup() {
        popupOverlay.style.display = "none";
        pendingStageStart = null;
      }

      popupCancel.addEventListener("click", () => {
        closeStartPopup();
      });
      popupConfirm.addEventListener("click", () => {
        if (pendingStageStart != null) {
          startStage(pendingStageStart);
        }
        closeStartPopup();
      });

      // ===== ë¡œë¹„ ë“œë¡œì‰ =====
      function drawLobby() {
        // ë°°ê²½ ê·¸ë¼ë””ì–¸íŠ¸: ì¸í…Œë¦¬ì–´/ê°„íŒì— ë”°ë¼ ì‚´ì§ ë°”ë€œ
        const g = ctx.createLinearGradient(0, 0, 0, LOGICAL_HEIGHT);
        if (upgrades.interior && upgrades.sign) {
          g.addColorStop(0, "#2b3a67");
          g.addColorStop(1, "#101322");
        } else if (upgrades.interior) {
          g.addColorStop(0, "#2c3e50");
          g.addColorStop(1, "#111");
        } else {
          g.addColorStop(0, "#333");
          g.addColorStop(1, "#111");
        }
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);

        // ì¸í…Œë¦¬ì–´ ì—…ê·¸ë ˆì´ë“œ: ë°”ë‹¥ íŒ¨í„´
        if (upgrades.interior) {
          const floorY = LOGICAL_HEIGHT - 80;
          ctx.fillStyle = "rgba(255,255,255,0.03)";
          ctx.fillRect(0, floorY, LOGICAL_WIDTH, 80);
          ctx.fillStyle = "rgba(255,255,255,0.05)";
          for (let x = -40; x < LOGICAL_WIDTH + 40; x += 16) {
            ctx.beginPath();
            ctx.moveTo(x, floorY + 4);
            ctx.lineTo(x + 40, floorY + 80);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(255,255,255,0.04)";
            ctx.stroke();
          }
        }

        // ì œëª©/ê°„íŒ
        const title = "ì˜¤ëŠ˜ì˜ ì¥ì‚¬";
        if (upgrades.sign) {
          // ë„¤ì˜¨ ê°„íŒ
          ctx.save();
          ctx.font = "20px system-ui";
          const textWidth = ctx.measureText(title).width;
          const padX = 16;
          const padY = 6;
          const x = LOGICAL_WIDTH / 2 - textWidth / 2 - padX;
          const y = 10;
          const w = textWidth + padX * 2;
          const h = 30;
          ctx.beginPath();
          ctx.roundRect(x, y, w, h, 16);
          const signGrad = ctx.createLinearGradient(x, y, x + w, y + h);
          signGrad.addColorStop(0, "#ff9a9e");
          signGrad.addColorStop(1, "#fad0c4");
          ctx.fillStyle = signGrad;
          ctx.shadowColor = "rgba(255,200,120,0.85)";
          ctx.shadowBlur = 18;
          ctx.fill();
          ctx.shadowBlur = 0;

          ctx.fillStyle = "#111";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(title, LOGICAL_WIDTH / 2, y + h / 2);
          ctx.restore();
        } else {
          // ê¸°ë³¸ í…ìŠ¤íŠ¸
          ctx.fillStyle = "#fff";
          ctx.font = "20px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.fillText(title, LOGICAL_WIDTH / 2, 12);
        }

        ctx.font = "12px system-ui";
        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText("ìŠ¤í…Œì´ì§€ë¥¼ ë“œë˜ê·¸í•´ì„œ ì„ íƒí•˜ì„¸ìš”", LOGICAL_WIDTH / 2, 40);

        const centerY = LOGICAL_HEIGHT / 2 + 20;
        for (let i = 0; i < STAGE_COUNT; i++) {
          const idx = i + 1;
          const x =
            mapOffsetX +
            i * (stageTileWidth + stageTileGap) +
            LOGICAL_WIDTH / 2 -
            stageTileWidth / 2;
          const y = centerY - stageTileHeight / 2;
          const unlocked = idx <= unlockedStage;
          const isCurrent = idx === currentStage;

          ctx.save();
          ctx.beginPath();
          ctx.roundRect(x, y, stageTileWidth, stageTileHeight, 14);
          let fill;
          if (!unlocked) fill = "#444";
          else if (isCurrent) fill = "#ffb347";
          else fill = "#2ecc71";
          ctx.fillStyle = fill;
          ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.4)";
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.fillStyle = isCurrent ? "#222" : "#fff";
          ctx.font = "bold 18px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(idx.toString(), x + stageTileWidth / 2, y + 26);

          ctx.font = "11px system-ui";
          ctx.textBaseline = "top";
          if (!unlocked) {
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillText("ì ê¹€", x + stageTileWidth / 2, y + 46);
          } else if (isCurrent) {
            ctx.fillText("í˜„ì¬", x + stageTileWidth / 2, y + 46);
          } else if (idx < currentStage) {
            ctx.fillText("í´ë¦¬ì–´", x + stageTileWidth / 2, y + 46);
          } else {
            ctx.fillText("ì…ì¥ ê°€ëŠ¥", x + stageTileWidth / 2, y + 46);
          }
          ctx.restore();
        }

        const curIdx = currentStage - 1;
        const cx =
          mapOffsetX +
          curIdx * (stageTileWidth + stageTileGap) +
          LOGICAL_WIDTH / 2;
        const cy = centerY - stageTileHeight / 2 - 14;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx - 8, cy - 10);
        ctx.lineTo(cx + 8, cy - 10);
        ctx.closePath();
        ctx.fillStyle = "#ffcc33";
        ctx.fill();

        ctx.font = "11px system-ui";
        ctx.fillStyle = "#ffcc33";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillText("í˜„ì¬ ìœ„ì¹˜", cx, cy - 12);
      }

      function lobbyPointerDown(pos) {
        lobbyDrag.active = true;
        lobbyDrag.startX = pos.x;
        lobbyDrag.startOffsetX = mapOffsetX;
        lobbyClickDownPos = { x: pos.x, y: pos.y };
      }

      function lobbyPointerMove(pos) {
        if (!lobbyDrag.active) return;
        const dx = pos.x - lobbyDrag.startX;
        mapOffsetX = lobbyDrag.startOffsetX + dx;
        clampMapOffset();
      }

      function lobbyPointerUp(pos) {
        if (lobbyDrag.active) lobbyDrag.active = false;
        if (!lobbyClickDownPos) return;
        const dx = pos.x - lobbyClickDownPos.x;
        const dy = pos.y - lobbyClickDownPos.y;
        const distSq = dx * dx + dy * dy;
        lobbyClickDownPos = null;
        if (distSq < 16) {
          const centerY = LOGICAL_HEIGHT / 2 + 20;
          for (let i = 0; i < STAGE_COUNT; i++) {
            const idx = i + 1;
            const x =
              mapOffsetX +
              i * (stageTileWidth + stageTileGap) +
              LOGICAL_WIDTH / 2 -
              stageTileWidth / 2;
            const y = centerY - stageTileHeight / 2;
            if (
              pos.x >= x &&
              pos.x <= x + stageTileWidth &&
              pos.y >= y &&
              pos.y <= y + stageTileHeight
            ) {
              if (idx > unlockedStage) {
                showToast("ì ê²¨ ìˆëŠ” ìŠ¤í…Œì´ì§€ì…ë‹ˆë‹¤.");
                return;
              }
              openStartPopup(idx);
              return;
            }
          }
        }
      }

      // ===== ìŠ¤í…Œì´ì§€ ë“œë¡œì‰ =====
      function wrapTextCanvas(text, maxWidth, font) {
        ctx.font = font;
        const words = text.split("");
        let line = "";
        const lines = [];
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i];
          const w = ctx.measureText(testLine).width;
          if (w > maxWidth && line !== "") {
            lines.push(line);
            line = words[i];
          } else {
            line = testLine;
          }
        }
        if (line) lines.push(line);
        return lines;
      }

      function drawStage() {
        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);

        // ìƒë‹¨ ì†ë‹˜ ì˜ì—­ (ë ˆì‹œí”¼ ì—…ê·¸ë ˆì´ë“œì— ë”°ë¼ ê·¸ë¼ë””ì–¸íŠ¸)
        const topHeight = LOGICAL_HEIGHT * 0.25;
        if (upgrades.recipe) {
          const topGrad = ctx.createLinearGradient(
            0,
            0,
            LOGICAL_WIDTH,
            topHeight
          );
          topGrad.addColorStop(0, "#1f2933");
          topGrad.addColorStop(1, "#273c75");
          ctx.fillStyle = topGrad;
        } else {
          ctx.fillStyle = "#1f1f1f";
        }
        ctx.fillRect(0, 0, LOGICAL_WIDTH, topHeight);

        // ì†ë‹˜ ì–¼êµ´
        const faceX = 60;
        const faceY = topHeight / 2;
        const faceR = 26;
        ctx.beginPath();
        ctx.arc(faceX, faceY, faceR, 0, Math.PI * 2);
        ctx.fillStyle = "#f1c27d";
        ctx.fill();

        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(faceX - 8, faceY - 4, 3, 0, Math.PI * 2);
        ctx.arc(faceX + 8, faceY - 4, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(faceX, faceY + 4, 12, 0.2 * Math.PI, 0.8 * Math.PI);
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        // ë§í’ì„  ì˜ì—­ (ë ˆì‹œí”¼ ì—…ê·¸ë ˆì´ë“œ ì‹œ ë” ê°•ì¡°)
        const bubbleX = 110;
        const bubbleY = 16;
        const bubbleW = LOGICAL_WIDTH - bubbleX - 12;
        const bubbleH = topHeight - 28;

        ctx.save();
        ctx.beginPath();
        ctx.roundRect(bubbleX, bubbleY, bubbleW, bubbleH, 12);
        if (upgrades.recipe) {
          const bGrad = ctx.createLinearGradient(
            bubbleX,
            bubbleY,
            bubbleX + bubbleW,
            bubbleY + bubbleH
          );
          bGrad.addColorStop(0, "#3b4256");
          bGrad.addColorStop(1, "#4b79a1");
          ctx.fillStyle = bGrad;
        } else {
          ctx.fillStyle = "#333";
        }
        ctx.fill();
        ctx.restore();

        // ë§í’ì„  ê¼¬ë¦¬
        ctx.beginPath();
        ctx.moveTo(bubbleX + 14, bubbleY + bubbleH);
        ctx.lineTo(bubbleX + 6, bubbleY + bubbleH + 10);
        ctx.lineTo(bubbleX + 24, bubbleY + bubbleH);
        ctx.closePath();
        ctx.fillStyle = upgrades.recipe ? "#3b4256" : "#333";
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        let orderStr = "ì˜¤ëŠ˜ì€ ì–´ë–¤ ë©”ë‰´ì¸ê°€ìš”?";
        if (order) {
          const ing = ingredients[order.ingredientIndex];
          const have = inventory[order.ingredientIndex] || 0;
          orderStr = `${ing.label} ${order.required}ê°œ ë¶€íƒí•´ìš”! (${have}/${order.required})`;
        }
        const lines = wrapTextCanvas(orderStr, bubbleW - 14, "12px system-ui");
        let ty = bubbleY + 8;
        for (const line of lines) {
          ctx.fillText(line, bubbleX + 8, ty);
          ty += 14;
        }

        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.moveTo(0, topHeight);
        ctx.lineTo(LOGICAL_WIDTH, topHeight);
        ctx.stroke();
        ctx.setLineDash([]);

        // ë³´ë“œ
        computeBoardGeometry();
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const tile = board[y][x];
            const baseX = boardOffsetX + x * tileSize;
            const baseY = boardOffsetY + y * tileSize;

            // íƒ€ì¼ ì¹¸ ë°°ê²½
            ctx.beginPath();
            ctx.roundRect(baseX + 2, baseY + 2, tileSize - 4, tileSize - 4, 8);
            ctx.fillStyle = "#333";
            ctx.fill();

            if (!tile) continue;

            let drawX = boardOffsetX + tile.drawX;
            let drawY = boardOffsetY + tile.drawY;

            let shakeOffsetX = 0;
            let shakeOffsetY = 0;
            if (tile.clearing || tile.shakeTime > 0) {
              const s = 1 + (tile.clearing ? (1 - tile.scale) * 4 : 1);
              shakeOffsetX = (Math.random() - 0.5) * 3 * s;
              shakeOffsetY = (Math.random() - 0.5) * 3 * s;
            }

            ctx.save();
            ctx.globalAlpha = tile.alpha;
            ctx.translate(
              drawX + tileSize / 2 + shakeOffsetX,
              drawY + tileSize / 2 + shakeOffsetY
            );
            ctx.scale(tile.scale, tile.scale);
            ctx.translate(-tileSize / 2, -tileSize / 2);

            ctx.beginPath();
            ctx.roundRect(4, 4, tileSize - 8, tileSize - 8, 7);
            ctx.fillStyle = ingredients[tile.type].color;
            ctx.fill();

            ctx.font = "bold 12px system-ui";
            ctx.fillStyle = "#111";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(
              ingredients[tile.type].label[0],
              tileSize / 2,
              tileSize / 2
            );

            ctx.restore();

            if (
              selectedTile &&
              selectedTile.x === x &&
              selectedTile.y === y &&
              phase === PHASE.IDLE
            ) {
              ctx.strokeStyle = "#fff";
              ctx.lineWidth = 2;
              ctx.strokeRect(baseX + 3, baseY + 3, tileSize - 6, tileSize - 6);
            }
          }
        }

        // íŒŒí‹°í´
        drawParticles();

        // ì½¤ë³´ í…ìŠ¤íŠ¸
        if (comboDisplayTimer > 0 && comboCount > 0) {
          ctx.save();
          const alpha = Math.min(1, comboDisplayTimer / 0.2);
          ctx.globalAlpha = alpha;
          ctx.font = "bold 20px system-ui";
          ctx.fillStyle = "#ffcc33";
          ctx.textAlign = "right";
          ctx.textBaseline = "bottom";
          ctx.fillText(
            `${comboCount} ì½¤ë³´!`,
            LOGICAL_WIDTH - 12,
            BOARD_TOP - 6
          );
          ctx.restore();
        }
      }

      // ===== ì…ë ¥ ì²˜ë¦¬ =====
      canvas.addEventListener("pointerdown", (e) => {
        if (popupOverlay.style.display === "flex") return;
        const pos = getCanvasPos(e);
        if (gameState === GAME_STATE.LOBBY) {
          lobbyPointerDown(pos);
        } else if (gameState === GAME_STATE.STAGE) {
          stagePointerDown(pos);
        }
        e.preventDefault();
      });

      canvas.addEventListener("pointermove", (e) => {
        if (popupOverlay.style.display === "flex") return;
        const pos = getCanvasPos(e);
        if (gameState === GAME_STATE.LOBBY) {
          lobbyPointerMove(pos);
        } else if (gameState === GAME_STATE.STAGE) {
          stagePointerMove(pos);
        }
        e.preventDefault();
      });

      canvas.addEventListener("pointerup", (e) => {
        if (popupOverlay.style.display === "flex") return;
        const pos = getCanvasPos(e);
        if (gameState === GAME_STATE.LOBBY) {
          lobbyPointerUp(pos);
        } else if (gameState === GAME_STATE.STAGE) {
          stagePointerUp(pos);
        }
        e.preventDefault();
      });

      canvas.addEventListener("pointercancel", () => {
        if (gameState === GAME_STATE.LOBBY) {
          lobbyDrag.active = false;
          lobbyClickDownPos = null;
        } else if (gameState === GAME_STATE.STAGE) {
          stagePointerDownInfo = null;
          selectedTile = null;
        }
      });

      // ===== ìŠ¤í…Œì´ì§€ í¬ì¸í„° ì²˜ë¦¬ =====
      function stagePointerDown(pos) {
        if (phase !== PHASE.IDLE) return;
        if (pos.y < LOGICAL_HEIGHT * 0.25) return;
        const tilePos = getTileFromPos(pos.x, pos.y);
        if (!tilePos) return;
        stagePointerDownInfo = {
          startX: pos.x,
          startY: pos.y,
          tileX: tilePos.x,
          tileY: tilePos.y,
        };
        selectedTile = { x: tilePos.x, y: tilePos.y };
      }

      function stagePointerMove(_pos) {
        // í•„ìš”í•˜ë©´ ë“œë˜ê·¸ ì‹œ ê°€ì´ë“œ ë„£ì„ ìˆ˜ ìˆìŒ
      }

      function stagePointerUp(pos) {
        if (!stagePointerDownInfo) {
          selectedTile = null;
          return;
        }
        if (phase !== PHASE.IDLE) {
          stagePointerDownInfo = null;
          selectedTile = null;
          return;
        }
        const dx = pos.x - stagePointerDownInfo.startX;
        const dy = pos.y - stagePointerDownInfo.startY;
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);
        const minDrag = 10;

        if (absDx < minDrag && absDy < minDrag) {
          stagePointerDownInfo = null;
          selectedTile = null;
          return;
        }

        let dirX = 0;
        let dirY = 0;
        if (absDx > absDy) dirX = dx > 0 ? 1 : -1;
        else dirY = dy > 0 ? 1 : -1;

        const x1 = stagePointerDownInfo.tileX;
        const y1 = stagePointerDownInfo.tileY;
        const x2 = x1 + dirX;
        const y2 = y1 + dirY;
        stagePointerDownInfo = null;
        selectedTile = null;

        if (x2 < 0 || x2 >= COLS || y2 < 0 || y2 >= ROWS) return;

        attemptSwapAndResolve(x1, y1, x2, y2);
      }

      // ===== ìŒì‹ ì œê³µ ë²„íŠ¼ =====
      serveButton.addEventListener("click", () => {
        if (!order) return;
        const have = inventory[order.ingredientIndex] || 0;
        if (have >= order.required) {
          clearStageAndReturnToLobby();
        } else {
          showToast("ì¬ë£Œê°€ ì•„ì§ ë¶€ì¡±í•´ìš”!");
        }
      });

      // ===== ë©”ì¸ ë£¨í”„ =====
      let lastTime = performance.now();
      function mainLoop() {
        const now = performance.now();
        const delta = (now - lastTime) / 1000;
        lastTime = now;

        if (gameState === GAME_STATE.STAGE) {
          updateAnimations(delta);
          updateStageLogic(delta);
          drawStage();
        } else {
          drawLobby();
        }

        requestAnimationFrame(mainLoop);
      }

      // ===== ì´ˆê¸°í™” =====
      updateHUD();
      mainLoop();
    </script>
  </body>
</html>
